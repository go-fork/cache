
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go.fork.vn/cache/config/config.go (100.0%)</option>
				
				<option value="file1">go.fork.vn/cache/driver/file.go (84.0%)</option>
				
				<option value="file2">go.fork.vn/cache/driver/memory.go (96.7%)</option>
				
				<option value="file3">go.fork.vn/cache/driver/mongodb.go (86.9%)</option>
				
				<option value="file4">go.fork.vn/cache/driver/redis.go (0.0%)</option>
				
				<option value="file5">go.fork.vn/cache/manager.go (98.6%)</option>
				
				<option value="file6">go.fork.vn/cache/mocks/driver.go (59.5%)</option>
				
				<option value="file7">go.fork.vn/cache/mocks/manager.go (0.0%)</option>
				
				<option value="file8">go.fork.vn/cache/mocks/service_provider.go (0.0%)</option>
				
				<option value="file9">go.fork.vn/cache/provider.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import "time"

// Config là cấu trúc cấu hình chính cho cache provider.
//
// Config định nghĩa các tùy chọn cấu hình cho cache manager và các driver.
// Nó hỗ trợ nhiều driver khác nhau như memory, file, redis và mongodb.
type Config struct {
        // DefaultDriver chỉ định driver mặc định để sử dụng
        // Options: memory, file, redis, mongodb
        DefaultDriver string `mapstructure:"default_driver" yaml:"default_driver"`

        // DefaultTTL là thời gian sống mặc định cho cache entries (giây)
        // 0 = không hết hạn, -1 = sử dụng mặc định của driver
        DefaultTTL int `mapstructure:"default_ttl" yaml:"default_ttl"`

        // Prefix là tiền tố cache key để tránh xung đột với ứng dụng khác
        Prefix string `mapstructure:"prefix" yaml:"prefix"`

        // Drivers chứa cấu hình cho từng driver
        Drivers DriversConfig `mapstructure:"drivers" yaml:"drivers"`
}

// DriversConfig chứa cấu hình cho tất cả các driver.
type DriversConfig struct {
        // Memory driver configuration
        Memory *DriverMemoryConfig `mapstructure:"memory" yaml:"memory"`

        // File driver configuration
        File *DriverFileConfig `mapstructure:"file" yaml:"file"`

        // Redis driver configuration
        Redis *DriverRedisConfig `mapstructure:"redis" yaml:"redis"`

        // MongoDB driver configuration
        MongoDB *DriverMongodbConfig `mapstructure:"mongodb" yaml:"mongodb"`
}

// DriverMemoryConfig là cấu hình cho memory driver.
type DriverMemoryConfig struct {
        // Enabled xác định có kích hoạt Memory driver không
        Enabled bool `mapstructure:"enabled" yaml:"enabled"`
        // DefaultTTL là thời gian hết hạn mặc định cho memory cache (giây)
        DefaultTTL int `mapstructure:"default_ttl" yaml:"default_ttl"`

        // CleanupInterval là khoảng thời gian dọn dẹp các item hết hạn (giây)
        CleanupInterval int `mapstructure:"cleanup_interval" yaml:"cleanup_interval"`

        // MaxItems là số lượng item tối đa trong memory cache (0 = unlimited)
        MaxItems int `mapstructure:"max_items" yaml:"max_items"`
}

// DriverFileConfig là cấu hình cho file driver.
type DriverFileConfig struct {
        // Enabled xác định có kích hoạt File driver không
        Enabled bool `mapstructure:"enabled" yaml:"enabled"`
        // Path là đường dẫn thư mục lưu trữ cache files
        Path string `mapstructure:"path" yaml:"path"`

        // DefaultTTL là thời gian hết hạn mặc định cho file cache (giây)
        DefaultTTL int `mapstructure:"default_ttl" yaml:"default_ttl"`

        // Extension là phần mở rộng cho cache files
        Extension string `mapstructure:"extension" yaml:"extension"`

        // CleanupInterval là khoảng thời gian dọn dẹp các file hết hạn (giây)
        CleanupInterval int `mapstructure:"cleanup_interval" yaml:"cleanup_interval"`
}

// DriverRedisConfig là cấu hình cho redis driver.
type DriverRedisConfig struct {
        // Enabled xác định có kích hoạt Redis driver không
        Enabled bool `mapstructure:"enabled" yaml:"enabled"`

        // DefaultTTL là thời gian hết hạn mặc định cho Redis cache (giây)
        DefaultTTL int `mapstructure:"default_ttl" yaml:"default_ttl"`

        // Serializer là định dạng serialization: json, gob, msgpack
        Serializer string `mapstructure:"serializer" yaml:"serializer"`
}

// DriverMongodbConfig là cấu hình cho mongodb driver.
type DriverMongodbConfig struct {
        // Enabled xác định có kích hoạt MongoDB driver không
        Enabled bool `mapstructure:"enabled" yaml:"enabled"`

        // Database là tên database để lưu trữ cache
        Database string `mapstructure:"database" yaml:"database"`

        // Collection là tên collection để lưu trữ cache
        Collection string `mapstructure:"collection" yaml:"collection"`

        // DefaultTTL là thời gian hết hạn mặc định cho MongoDB cache (giây)
        DefaultTTL int `mapstructure:"default_ttl" yaml:"default_ttl"`

        // Hits là số lần cache hit (readonly, được quản lý bởi driver)
        Hits int64 `mapstructure:"hits" yaml:"hits"`

        // Misses là số lần cache miss (readonly, được quản lý bởi driver)
        Misses int64 `mapstructure:"misses" yaml:"misses"`
}

// DefaultConfig trả về cấu hình mặc định cho cache.
//
// Cấu hình mặc định sử dụng memory driver với TTL 1 giờ.
//
// Returns:
//   - *Config: Cấu hình mặc định
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DefaultDriver: "memory",
                DefaultTTL:    3600, // 1 hour
                Prefix:        "cache:",
                Drivers: DriversConfig{
                        Memory: &amp;DriverMemoryConfig{
                                DefaultTTL:      3600, // 1 hour
                                CleanupInterval: 600,  // 10 minutes
                                MaxItems:        10000,
                        },
                        File: &amp;DriverFileConfig{
                                Path:            "./storage/cache",
                                DefaultTTL:      3600, // 1 hour
                                Extension:       ".cache",
                                CleanupInterval: 600, // 10 minutes
                        },
                        Redis: &amp;DriverRedisConfig{
                                Enabled:    true,
                                DefaultTTL: 3600, // 1 hour
                                Serializer: "json",
                        },
                        MongoDB: &amp;DriverMongodbConfig{
                                Enabled:    true,
                                Database:   "cache_db",
                                Collection: "cache_items",
                                DefaultTTL: 3600, // 1 hour
                                Hits:       0,
                                Misses:     0,
                        },
                },
        }
}</span>

// GetDefaultExpiration trả về thời gian hết hạn mặc định theo kiểu time.Duration.
//
// Returns:
//   - time.Duration: Thời gian hết hạn mặc định
func (c *Config) GetDefaultExpiration() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.DefaultTTL) * time.Second
}</span>

// GetMemoryDefaultExpiration trả về thời gian hết hạn mặc định cho memory driver.
//
// Returns:
//   - time.Duration: Thời gian hết hạn mặc định cho memory driver
func (m *DriverMemoryConfig) GetDefaultExpiration() time.Duration <span class="cov8" title="1">{
        return time.Duration(m.DefaultTTL) * time.Second
}</span>

// GetCleanupInterval trả về khoảng thời gian dọn dẹp cho memory driver.
//
// Returns:
//   - time.Duration: Khoảng thời gian dọn dẹp
func (m *DriverMemoryConfig) GetCleanupInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(m.CleanupInterval) * time.Second
}</span>

// GetFileDefaultExpiration trả về thời gian hết hạn mặc định cho file driver.
//
// Returns:
//   - time.Duration: Thời gian hết hạn mặc định cho file driver
func (f *DriverFileConfig) GetDefaultExpiration() time.Duration <span class="cov8" title="1">{
        return time.Duration(f.DefaultTTL) * time.Second
}</span>

// GetFileCleanupInterval trả về khoảng thời gian dọn dẹp cho file driver.
//
// Returns:
//   - time.Duration: Khoảng thời gian dọn dẹp
func (f *DriverFileConfig) GetFileCleanupInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(f.CleanupInterval) * time.Second
}</span>

// GetRedisDefaultExpiration trả về thời gian hết hạn mặc định cho redis driver.
//
// Returns:
//   - time.Duration: Thời gian hết hạn mặc định cho redis driver
func (r *DriverRedisConfig) GetDefaultExpiration() time.Duration <span class="cov8" title="1">{
        return time.Duration(r.DefaultTTL) * time.Second
}</span>

// GetMongoDBDefaultExpiration trả về thời gian hết hạn mặc định cho mongodb driver.
//
// Returns:
//   - time.Duration: Thời gian hết hạn mặc định cho mongodb driver
func (m *DriverMongodbConfig) GetDefaultExpiration() time.Duration <span class="cov8" title="1">{
        return time.Duration(m.DefaultTTL) * time.Second
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package driver

import (
        "context"
        "crypto/sha1"
        "encoding/gob"
        "encoding/hex"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "go.fork.vn/cache/config"
)

type FileDriver interface {
        // Driver định nghĩa các phương thức cần thiết cho một cache driver.
        Driver
}

// FileDriver cài đặt cache driver sử dụng file system.
//
// FileDriver lưu trữ dữ liệu cache dưới dạng các file trên hệ thống file,
// với mỗi cache entry tương ứng với một file riêng biệt. Driver này thích hợp
// cho các ứng dụng cần persistence và có thể phục hồi dữ liệu cache sau khi khởi động lại.
// Nó cũng hỗ trợ TTL (Time To Live) và tự động dọn dẹp các entry đã hết hạn.
type fileDriver struct {
        directory         string        // Đường dẫn thư mục lưu trữ cache
        defaultExpiration time.Duration // Thời gian sống mặc định cho các entry không chỉ định TTL
        mu                sync.RWMutex  // Mutex cho các thao tác thread-safe
        janitorInterval   time.Duration // Khoảng thời gian giữa các lần dọn dẹp
        stopJanitor       chan bool     // Channel để dừng goroutine dọn dẹp
        janitorRunning    bool          // Flag đánh dấu goroutine dọn dẹp đang chạy
        hits              int64         // Số lần cache hit
        misses            int64         // Số lần cache miss
}

// FileCache là cấu trúc lưu trữ dữ liệu trong file.
//
// Cấu trúc này được dùng để serialize và deserialize dữ liệu cache
// khi lưu trữ và đọc từ file. Nó chứa giá trị cần cache và thời gian hết hạn.
type FileCache struct {
        Value      interface{} // Giá trị được lưu trong cache
        Expiration int64       // Thời điểm hết hạn (UnixNano), 0 nếu không hết hạn
}

// NewFileDriver tạo một file driver mới với các tùy chọn mặc định.
//
// Phương thức này khởi tạo một FileDriver mới với thư mục lưu trữ được chỉ định
// và các giá trị mặc định cho defaultExpiration (5 phút) và cleanupInterval (10 phút).
//
// Params:
//   - directory: Đường dẫn thư mục để lưu trữ các file cache
//
// Returns:
//   - *FileDriver: Driver đã được khởi tạo
//   - error: Lỗi nếu không thể tạo thư mục cache
func NewFileDriver(cfg config.DriverFileConfig) (FileDriver, error) <span class="cov8" title="1">{
        // Tạo thư mục nếu không tồn tại
        if err := os.MkdirAll(cfg.Path, 0755); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unable to create cache directory: %w", err)
        }</span>

        <span class="cov8" title="1">driver := &amp;fileDriver{
                directory:         cfg.Path,
                defaultExpiration: time.Duration(cfg.DefaultTTL) * time.Second,
                janitorInterval:   time.Duration(cfg.CleanupInterval) * time.Second,
                stopJanitor:       make(chan bool),
        }

        // Chỉ chạy janitor nếu có khoảng thời gian dọn dẹp &gt; 0
        if cfg.CleanupInterval &gt; 0 </span><span class="cov8" title="1">{
                go driver.startJanitor()
                driver.janitorRunning = true
        }</span>

        <span class="cov8" title="1">return driver, nil</span>
}

// keyToFilename chuyển đổi key thành tên file an toàn.
//
// Phương thức này chuyển đổi một cache key thành đường dẫn file đầy đủ trong thư mục cache.
// Trong thực tế, nên sử dụng một hàm hash như md5 hoặc sha1 để tránh các vấn đề với ký tự đặc biệt
// và đảm bảo tên file hợp lệ trên hệ thống file.
//
// Params:
//   - key: Cache key cần chuyển đổi
//
// Returns:
//   - string: Đường dẫn đầy đủ đến file cache
func (d *fileDriver) keyToFilename(key string) (string, error) <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid key: key is empty")
        }</span>
        <span class="cov8" title="1">for _, c := range key </span><span class="cov8" title="1">{
                if c == '/' || c == '\\' || c == 0 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid key: contains forbidden character")
                }</span>
        }
        <span class="cov8" title="1">h := sha1.New()
        _, err := h.Write([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid key: %w", err)
        }</span>
        <span class="cov8" title="1">hash := hex.EncodeToString(h.Sum(nil))
        return filepath.Join(d.directory, hash), nil</span>
}

// Get lấy một giá trị từ cache.
//
// Phương thức này đọc và giải mã dữ liệu từ file cache tương ứng với key được chỉ định.
// Nếu file không tồn tại hoặc đã hết hạn, phương thức sẽ trả về false và cập nhật
// bộ đếm miss. Nếu tìm thấy và còn hạn, phương thức trả về giá trị và cập nhật bộ đếm hit.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần lấy
//
// Returns:
//   - interface{}: Giá trị được lưu trong cache (nil nếu không tìm thấy)
//   - bool: true nếu tìm thấy key và chưa hết hạn, false nếu ngược lại
func (d *fileDriver) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        filename, err := d.keyToFilename(key)
        if err != nil </span><span class="cov0" title="0">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                return nil, false
        }</span>

        // Kiểm tra xem file có tồn tại không
        <span class="cov8" title="1">if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov8" title="1">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                return nil, false
        }</span>

        // Mở file
        <span class="cov8" title="1">file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                return nil, false
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Giải mã dữ liệu
        var cache FileCache
        decoder := gob.NewDecoder(file)
        if err = decoder.Decode(&amp;cache); err != nil </span><span class="cov8" title="1">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                return nil, false
        }</span>

        // Kiểm tra xem đã hết hạn chưa
        <span class="cov8" title="1">if cache.Expiration &gt; 0 &amp;&amp; time.Now().UnixNano() &gt; cache.Expiration </span><span class="cov8" title="1">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                os.Remove(filename) // Xóa file đã hết hạn
                return nil, false
        }</span>

        <span class="cov8" title="1">d.mu.Lock()
        d.hits++
        d.mu.Unlock()
        return cache.Value, true</span>
}

// Set đặt một giá trị vào cache với TTL tùy chọn.
//
// Phương thức này mã hóa và lưu trữ một cặp key-value vào một file trong thư mục cache.
// Thời gian sống (TTL) có thể được chỉ định, hoặc sử dụng giá trị mặc định nếu ttl = 0,
// hoặc không có thời hạn nếu ttl = -1.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key để lưu giá trị
//   - value: Giá trị cần lưu trữ
//   - ttl: Thời gian sống của giá trị (0 để sử dụng mặc định, -1 để không hết hạn)
//
// Returns:
//   - error: Lỗi nếu có trong quá trình tạo, mã hóa hoặc ghi file
func (d *fileDriver) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        filename, err := d.keyToFilename(key)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">var exp int64

        if ttl == 0 </span><span class="cov8" title="1">{
                if d.defaultExpiration &gt; 0 </span><span class="cov8" title="1">{
                        exp = time.Now().Add(d.defaultExpiration).UnixNano()
                }</span>
        } else<span class="cov8" title="1"> if ttl &gt; 0 </span><span class="cov8" title="1">{
                exp = time.Now().Add(ttl).UnixNano()
        }</span>

        // Tạo cấu trúc cache
        <span class="cov8" title="1">cache := FileCache{
                Value:      value,
                Expiration: exp,
        }

        // Mở file để ghi
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create cache file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Mã hóa và ghi vào file
        encoder := gob.NewEncoder(file)
        return encoder.Encode(cache)</span>
}

// Has kiểm tra xem một key có tồn tại trong cache không.
//
// Phương thức này xác định liệu một key có tồn tại trong cache và chưa hết hạn hay không.
// Nó sử dụng phương thức Get để thực hiện kiểm tra và do đó cũng cập nhật bộ đếm hit/miss.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần kiểm tra
//
// Returns:
//   - bool: true nếu key tồn tại và chưa hết hạn, false nếu ngược lại
func (d *fileDriver) Has(ctx context.Context, key string) bool <span class="cov8" title="1">{
        _, exists := d.Get(ctx, key)
        return exists
}</span>

// Delete xóa một key khỏi cache.
//
// Phương thức này xóa file cache tương ứng với key được chỉ định.
// Nếu file không tồn tại, thao tác này không có tác dụng và không trả về lỗi.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa file
func (d *fileDriver) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        filename, err := d.keyToFilename(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // File không tồn tại, không cần xóa
        }</span>
        <span class="cov8" title="1">return os.Remove(filename)</span>
}

// Flush xóa tất cả các key khỏi cache.
//
// Phương thức này xóa tất cả các file trong thư mục cache, làm trống hoàn toàn bộ nhớ cache.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa files
func (d *fileDriver) Flush(ctx context.Context) error <span class="cov8" title="1">{
        dir, err := os.Open(d.directory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dir.Close()

        names, err := dir.Readdirnames(-1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var errs []error
        for _, name := range names </span><span class="cov8" title="1">{
                err = os.Remove(filepath.Join(d.directory, name))
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("file '%s': %w", name, err))
                }</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Flush errors: %v", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetMultiple lấy nhiều giá trị từ cache.
//
// Phương thức này lấy các giá trị tương ứng với nhiều key trong một lần gọi.
// Nó thực hiện gọi Get cho từng key và tổng hợp kết quả.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần lấy
//
// Returns:
//   - map[string]interface{}: Map chứa các key tìm thấy và giá trị tương ứng
//   - []string: Danh sách các key không tìm thấy hoặc đã hết hạn
func (d *fileDriver) GetMultiple(ctx context.Context, keys []string) (map[string]interface{}, []string) <span class="cov8" title="1">{
        results := make(map[string]interface{})
        missed := make([]string, 0)

        for _, key := range keys </span><span class="cov8" title="1">{
                value, found := d.Get(ctx, key)
                if found </span><span class="cov8" title="1">{
                        results[key] = value
                }</span> else<span class="cov8" title="1"> {
                        missed = append(missed, key)
                }</span>
        }

        <span class="cov8" title="1">return results, missed</span>
}

// SetMultiple đặt nhiều giá trị vào cache.
//
// Phương thức này lưu trữ nhiều cặp key-value vào cache trong một lần gọi
// với cùng một thời gian sống. Nó thực hiện gọi Set cho từng cặp key-value.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - values: Map chứa các key và giá trị tương ứng cần lưu trữ
//   - ttl: Thời gian sống chung cho tất cả các giá trị
//
// Returns:
//   - error: Lỗi nếu có trong quá trình thực hiện
func (d *fileDriver) SetMultiple(ctx context.Context, values map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        for key, value := range values </span><span class="cov8" title="1">{
                if err := d.Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// DeleteMultiple xóa nhiều key khỏi cache.
//
// Phương thức này xóa nhiều key và giá trị tương ứng khỏi cache trong một lần gọi.
// Nó thực hiện gọi Delete cho từng key.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình thực hiện
func (d *fileDriver) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if err := d.Delete(ctx, key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy.
//
// Phương thức này kiểm tra xem một key có tồn tại trong cache không, nếu có thì
// trả về giá trị tương ứng. Nếu key không tồn tại hoặc đã hết hạn, phương thức
// sẽ gọi hàm callback để lấy dữ liệu, lưu kết quả vào cache và trả về giá trị đó.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần tìm hoặc lưu vào cache
//   - ttl: Thời gian sống của giá trị nếu phải lấy từ callback
//   - callback: Hàm được gọi để lấy dữ liệu khi key không có trong cache
//
// Returns:
//   - interface{}: Giá trị từ cache hoặc từ callback
//   - error: Lỗi nếu có trong quá trình thực hiện hoặc từ callback
func (d *fileDriver) Remember(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        value, found := d.Get(ctx, key)
        if found </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">if callback == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("callback function is required")
        }</span>

        <span class="cov8" title="1">value, err := callback()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = d.Set(ctx, key, value, ttl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// Stats trả về thông tin thống kê về cache.
//
// Phương thức này thu thập và trả về các thông tin thống kê về trạng thái
// hiện tại của file cache như số lượng file, tổng dung lượng, số lần hit/miss, v.v.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - map[string]interface{}: Map chứa các thông tin thống kê
func (d *fileDriver) Stats(ctx context.Context) map[string]interface{} <span class="cov8" title="1">{
        var itemCount int
        var size int64

        // Đếm số lượng file và kích thước
        _ = filepath.Walk(d.directory, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        itemCount++
                        size += info.Size()
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">d.mu.RLock()
        defer d.mu.RUnlock()

        return map[string]interface{}{
                "count":  itemCount,
                "size":   size,
                "hits":   d.hits,
                "misses": d.misses,
                "type":   "file",
                "path":   d.directory,
        }</span>
}

// Close giải phóng tài nguyên của driver.
//
// Phương thức này dừng goroutine janitor nếu đang chạy và giải phóng
// các tài nguyên khác được sử dụng bởi driver.
//
// Returns:
//   - error: Lỗi nếu có trong quá trình giải phóng tài nguyên
func (d *fileDriver) Close() error <span class="cov8" title="1">{
        if d.janitorRunning </span><span class="cov8" title="1">{
                d.stopJanitor &lt;- true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// startJanitor bắt đầu một routine định kỳ dọn dẹp các file đã hết hạn.
//
// Phương thức này chạy một goroutine định kỳ gọi deleteExpired để
// xóa các file cache đã hết hạn theo khoảng thời gian đã cấu hình.
func (d *fileDriver) startJanitor() <span class="cov8" title="1">{
        ticker := time.NewTicker(d.janitorInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        d.deleteExpired()</span>
                case &lt;-d.stopJanitor:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// deleteExpired xóa tất cả các file đã hết hạn.
//
// Phương thức này quét qua tất cả các file trong thư mục cache,
// đọc thông tin thời gian hết hạn và xóa file nếu đã quá hạn.
func (d *fileDriver) deleteExpired() <span class="cov8" title="1">{
        now := time.Now().UnixNano()
        dir, err := os.Open(d.directory)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer dir.Close()

        names, err := dir.Readdirnames(-1)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for _, name := range names </span><span class="cov8" title="1">{
                filename := filepath.Join(d.directory, name)
                file, err := os.Open(filename)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var cache FileCache
                decoder := gob.NewDecoder(file)
                if err = decoder.Decode(&amp;cache); err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        continue</span>
                }
                <span class="cov8" title="1">file.Close()

                if cache.Expiration &gt; 0 &amp;&amp; now &gt; cache.Expiration </span><span class="cov8" title="1">{
                        _ = os.Remove(filename) // Ignore error, continue
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package driver

import (
        "context"
        "sync"
        "time"

        "go.fork.vn/cache/config"
)

// Item đại diện cho một mục trong memory cache.
//
// Cấu trúc này lưu trữ giá trị được cache và thời điểm hết hạn của nó.
// Nó được sử dụng nội bộ bởi MemoryDriver để quản lý các cache entry.
type Item struct {
        Value      interface{} // Giá trị được lưu trong cache
        Expiration int64       // Thời điểm hết hạn (UnixNano), 0 nếu không hết hạn
}

// Expired kiểm tra xem item đã hết hạn hay chưa.
//
// Phương thức này so sánh thời điểm hết hạn của item với thời gian hiện tại
// để xác định xem item đã hết hạn hay chưa.
//
// Returns:
//   - bool: true nếu item đã hết hạn, false nếu chưa hết hạn hoặc không có thời hạn
func (i *Item) Expired() bool <span class="cov8" title="1">{
        if i.Expiration == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return time.Now().UnixNano() &gt; i.Expiration</span>
}

type MemoryDriver interface {
        Driver
}

// memoryDriver cài đặt cache driver sử dụng memory (in-memory).
//
// memoryDriver lưu trữ dữ liệu cache trong bộ nhớ chính của ứng dụng.
// Driver này cung cấp khả năng truy xuất dữ liệu nhanh nhất nhưng dữ liệu sẽ
// bị mất khi ứng dụng khởi động lại. Nó hỗ trợ TTL và tự động dọn dẹp
// các entry đã hết hạn.
type memoryDriver struct {
        items             map[string]Item // Map lưu trữ các cache item
        mu                sync.RWMutex    // Mutex cho các thao tác thread-safe
        janitorInterval   time.Duration   // Khoảng thời gian giữa các lần dọn dẹp
        stopJanitor       chan bool       // Channel để dừng goroutine dọn dẹp
        janitorRunning    bool            // Flag đánh dấu goroutine dọn dẹp đang chạy
        defaultExpiration time.Duration   // Thời gian sống mặc định cho các entry không chỉ định TTL
        hits              int64           // Số lần cache hit
        misses            int64           // Số lần cache miss
}

// NewMemoryDriver tạo một memory driver mới với các tùy chọn mặc định.
//
// Phương thức này khởi tạo một MemoryDriver mới với các giá trị mặc định cho
// defaultExpiration (5 phút) và cleanupInterval (10 phút).
//
// Returns:
//   - *MemoryDriver: Driver đã được khởi tạo
func NewMemoryDriver(cfg config.DriverMemoryConfig) MemoryDriver <span class="cov8" title="1">{
        driver := &amp;memoryDriver{
                items:             make(map[string]Item),
                janitorInterval:   time.Duration(cfg.CleanupInterval) * time.Second,
                defaultExpiration: time.Duration(cfg.DefaultTTL) * time.Second,
                stopJanitor:       make(chan bool),
        }

        // Chỉ chạy janitor nếu có khoảng thời gian dọn dẹp &gt; 0
        if cfg.CleanupInterval &gt; 0 </span><span class="cov8" title="1">{
                go driver.startJanitor()
                driver.janitorRunning = true
        }</span>

        <span class="cov8" title="1">return driver</span>
}

// Get lấy một giá trị từ cache.
//
// Phương thức này tìm kiếm và trả về giá trị từ cache dựa trên key được cung cấp.
// Nếu key không tồn tại hoặc đã hết hạn, phương thức trả về false ở giá trị thứ hai
// và cập nhật bộ đếm miss. Nếu tìm thấy và còn hạn, phương thức trả về giá trị và
// cập nhật bộ đếm hit.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần tìm
//
// Returns:
//   - interface{}: Giá trị được lưu trong cache (nil nếu không tìm thấy)
//   - bool: true nếu tìm thấy key và chưa hết hạn, false nếu ngược lại
func (d *memoryDriver) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        d.mu.RLock()
        item, found := d.items[key]
        d.mu.RUnlock()

        if !found </span><span class="cov8" title="1">{
                d.mu.Lock()
                d.misses++
                d.mu.Unlock()
                return nil, false
        }</span>

        <span class="cov8" title="1">if item.Expired() </span><span class="cov8" title="1">{
                d.mu.Lock()
                d.misses++
                delete(d.items, key)
                d.mu.Unlock()
                return nil, false
        }</span>

        <span class="cov8" title="1">d.mu.Lock()
        d.hits++
        d.mu.Unlock()
        return item.Value, true</span>
}

// Set đặt một giá trị vào cache với TTL tùy chọn.
//
// Phương thức này lưu trữ một cặp key-value vào cache với thời gian sống
// được chỉ định. Nếu key đã tồn tại, giá trị sẽ bị ghi đè.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key để lưu giá trị
//   - value: Giá trị cần lưu trữ
//   - ttl: Thời gian sống của giá trị (0 để sử dụng mặc định, -1 để không hết hạn)
//
// Returns:
//   - error: Luôn trả về nil trong memory driver
func (d *memoryDriver) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        var exp int64

        if ttl == 0 </span><span class="cov8" title="1">{
                if d.defaultExpiration &gt; 0 </span><span class="cov8" title="1">{
                        exp = time.Now().Add(d.defaultExpiration).UnixNano()
                }</span>
        } else<span class="cov8" title="1"> if ttl &gt; 0 </span><span class="cov8" title="1">{
                exp = time.Now().Add(ttl).UnixNano()
        }</span>

        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()

        d.items[key] = Item{
                Value:      value,
                Expiration: exp,
        }
        return nil</span>
}

// Has kiểm tra xem một key có tồn tại trong cache không.
//
// Phương thức này xác định liệu một key có tồn tại trong cache và chưa hết hạn hay không.
// Nó sử dụng phương thức Get để thực hiện kiểm tra và do đó cũng cập nhật bộ đếm hit/miss.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần kiểm tra
//
// Returns:
//   - bool: true nếu key tồn tại và chưa hết hạn, false nếu ngược lại
func (d *memoryDriver) Has(ctx context.Context, key string) bool <span class="cov8" title="1">{
        _, exists := d.Get(ctx, key)
        return exists
}</span>

// Delete xóa một key khỏi cache.
//
// Phương thức này xóa key và giá trị tương ứng khỏi cache nếu tồn tại.
// Nếu key không tồn tại, thao tác này không có tác dụng và không trả về lỗi.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần xóa
//
// Returns:
//   - error: Luôn trả về nil trong memory driver
func (d *memoryDriver) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        delete(d.items, key)
        return nil
}</span>

// Flush xóa tất cả các key khỏi cache.
//
// Phương thức này xóa tất cả dữ liệu trong cache, làm trống hoàn toàn bộ nhớ cache.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - error: Luôn trả về nil trong memory driver
func (d *memoryDriver) Flush(ctx context.Context) error <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        d.items = make(map[string]Item)
        return nil
}</span>

// GetMultiple lấy nhiều giá trị từ cache.
//
// Phương thức này lấy các giá trị tương ứng với nhiều key trong một lần gọi.
// Nó thực hiện gọi Get cho từng key và tổng hợp kết quả.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần lấy
//
// Returns:
//   - map[string]interface{}: Map chứa các key tìm thấy và giá trị tương ứng
//   - []string: Danh sách các key không tìm thấy hoặc đã hết hạn
func (d *memoryDriver) GetMultiple(ctx context.Context, keys []string) (map[string]interface{}, []string) <span class="cov8" title="1">{
        results := make(map[string]interface{})
        missed := make([]string, 0)

        for _, key := range keys </span><span class="cov8" title="1">{
                value, found := d.Get(ctx, key)
                if found </span><span class="cov8" title="1">{
                        results[key] = value
                }</span> else<span class="cov8" title="1"> {
                        missed = append(missed, key)
                }</span>
        }

        <span class="cov8" title="1">return results, missed</span>
}

// SetMultiple đặt nhiều giá trị vào cache.
//
// Phương thức này lưu trữ nhiều cặp key-value vào cache trong một lần gọi
// với cùng một thời gian sống. Nó thực hiện gọi Set cho từng cặp key-value.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - values: Map chứa các key và giá trị tương ứng cần lưu trữ
//   - ttl: Thời gian sống chung cho tất cả các giá trị
//
// Returns:
//   - error: Lỗi nếu có trong quá trình thực hiện (luôn là nil trong memory driver)
func (d *memoryDriver) SetMultiple(ctx context.Context, values map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        for key, value := range values </span><span class="cov8" title="1">{
                if err := d.Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// DeleteMultiple xóa nhiều key khỏi cache.
//
// Phương thức này xóa nhiều key và giá trị tương ứng khỏi cache trong một lần gọi.
// Nó thực hiện gọi Delete cho từng key.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình thực hiện (luôn là nil trong memory driver)
func (d *memoryDriver) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if err := d.Delete(ctx, key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy.
//
// Phương thức này kiểm tra xem một key có tồn tại trong cache không, nếu có thì
// trả về giá trị tương ứng. Nếu key không tồn tại hoặc đã hết hạn, phương thức
// sẽ gọi hàm callback để lấy dữ liệu, lưu kết quả vào cache và trả về giá trị đó.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần tìm hoặc lưu vào cache
//   - ttl: Thời gian sống của giá trị nếu phải lấy từ callback
//   - callback: Hàm được gọi để lấy dữ liệu khi key không có trong cache
//
// Returns:
//   - interface{}: Giá trị từ cache hoặc từ callback
//   - error: Lỗi nếu có trong quá trình thực hiện hoặc từ callback
func (d *memoryDriver) Remember(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        // Kiểm tra cache trước
        value, found := d.Get(ctx, key)
        if found </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        // Không tìm thấy, gọi callback
        <span class="cov8" title="1">value, err := callback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Lưu kết quả vào cache
        <span class="cov8" title="1">err = d.Set(ctx, key, value, ttl)
        return value, err</span>
}

// Stats trả về thông tin thống kê về cache.
//
// Phương thức này thu thập và trả về các thông tin thống kê về trạng thái
// hiện tại của memory cache như số lượng item, số lần hit/miss, v.v.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - map[string]interface{}: Map chứa các thông tin thống kê
func (d *memoryDriver) Stats(ctx context.Context) map[string]interface{} <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        itemCount := len(d.items)
        stats := map[string]interface{}{
                "count":  itemCount,
                "hits":   d.hits,
                "misses": d.misses,
                "type":   "memory",
        }

        return stats
}</span>

// Close giải phóng tài nguyên của driver.
//
// Phương thức này dừng goroutine janitor nếu đang chạy và giải phóng
// các tài nguyên khác được sử dụng bởi driver.
//
// Returns:
//   - error: Lỗi nếu có trong quá trình giải phóng tài nguyên (luôn là nil trong memory driver)
func (d *memoryDriver) Close() error <span class="cov8" title="1">{
        if d.janitorRunning </span><span class="cov8" title="1">{
                d.stopJanitor &lt;- true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// startJanitor bắt đầu một routine định kỳ dọn dẹp các mục đã hết hạn.
//
// Phương thức này chạy một goroutine định kỳ gọi deleteExpired để
// xóa các cache entry đã hết hạn theo khoảng thời gian đã cấu hình.
func (d *memoryDriver) startJanitor() <span class="cov8" title="1">{
        ticker := time.NewTicker(d.janitorInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        d.deleteExpired()</span>
                case &lt;-d.stopJanitor:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// deleteExpired xóa tất cả các mục đã hết hạn.
//
// Phương thức này quét qua tất cả các item trong cache map,
// kiểm tra thời gian hết hạn và xóa những item đã quá hạn.
func (d *memoryDriver) deleteExpired() <span class="cov8" title="1">{
        now := time.Now().UnixNano()

        d.mu.Lock()
        defer d.mu.Unlock()

        for k, v := range d.items </span><span class="cov8" title="1">{
                if v.Expiration &gt; 0 &amp;&amp; now &gt; v.Expiration </span><span class="cov8" title="1">{
                        delete(d.items, k)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package driver

import (
        "context"
        "time"

        "go.fork.vn/cache/config"
        "go.fork.vn/mongodb"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// MongoCacheItem đại diện cho một mục trong MongoDB cache.
//
// Cấu trúc này lưu trữ dữ liệu cache dưới dạng document trong MongoDB,
// với các trường cần thiết như key, value, thời gian hết hạn và thời gian tạo.
type MongoCacheItem struct {
        Key        string      `bson:"_id"`        // Cache key, sử dụng như primary key
        Value      interface{} `bson:"value"`      // Giá trị được lưu trong cache
        Expiration int64       `bson:"expiration"` // Thời điểm hết hạn (UnixNano), 0 nếu không hết hạn
        CreatedAt  time.Time   `bson:"created_at"` // Thời điểm tạo cache item
}

type MongoDBDriver interface {
        Driver
        // ensureIndexes tạo các index cần thiết cho MongoDB collection.
        ensureIndexes(ctx context.Context) error
}

// mongoDBDriver cài đặt cache driver sử dụng MongoDB.
//
// mongoDBDriver lưu trữ dữ liệu cache trong một collection MongoDB.
// Driver này phù hợp cho các ứng dụng yêu cầu persistence, phân tán dữ liệu
// và cần tìm kiếm trong dữ liệu cache. MongoDB TTL index được sử dụng để tự động
// xóa các document đã hết hạn.
type mongoDBDriver struct {
        mongodb    *mongodb.Manager // Service Provider mongoDB manager
        config     config.DriverMongodbConfig
        database   *mongo.Database   // MongoDB database để lưu trữ cache
        collection *mongo.Collection // MongoDB collection để lưu trữ cache
}

// NewMongoDBDriver tạo một MongoDB driver mới với cấu hình mặc định.
//
// Phương thức này khởi tạo một MongoDBDriver mới với thông tin kết nối cơ bản.
// Nó sử dụng giá trị mặc định cho defaultExpiration là 5 phút.
//
// Params:
//   - config: config.DriverMongodbConfig,
//   - manager: mongodb.Manager
//
// Returns:
//   - *MongoDBDriver: Driver đã được khởi tạo
//   - error: Lỗi nếu không thể kết nối đến MongoDB hoặc tạo indices
func NewMongoDBDriver(cfg config.DriverMongodbConfig, manager mongodb.Manager) (MongoDBDriver, error) <span class="cov8" title="1">{
        driver := &amp;mongoDBDriver{
                mongodb:    &amp;manager,
                config:     cfg,
                database:   manager.DatabaseWithName(cfg.Database),
                collection: manager.DatabaseWithName(cfg.Database).Collection(cfg.Collection),
        }

        // Tạo indices cần thiết
        if err := driver.ensureIndexes(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return driver, nil</span>
}

// ensureIndexes tạo các index cần thiết cho MongoDB collection.
//
// Phương thức này tạo TTL index trên trường expiration để MongoDB tự động
// xóa các document đã hết hạn. TTL index kiểm tra các document có expiration &gt; 0
// và xóa chúng khi thời gian hiện tại vượt quá giá trị expiration.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - error: Lỗi nếu có trong quá trình tạo index
func (d *mongoDBDriver) ensureIndexes(ctx context.Context) error <span class="cov8" title="1">{
        // Tạo TTL index trên trường expiration
        // Index này sẽ tự động xóa documents khi expiration time đến
        indexModel := mongo.IndexModel{
                Keys: bson.D{
                        {Key: "expiration", Value: 1}, // Index trên trường expiration
                },
                Options: options.Index().
                        SetExpireAfterSeconds(0). // TTL index với 0 seconds để sử dụng giá trị trong document
                        SetPartialFilterExpression(bson.D{
                                {Key: "expiration", Value: bson.D{{Key: "$gt", Value: 0}}}, // Chỉ áp dụng cho document có expiration &gt; 0
                        }).
                        SetName("cache_expiration_ttl"), // Tên index
        }

        // Tạo index
        _, err := d.collection.Indexes().CreateOne(ctx, indexModel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Tạo index cho _id nếu chưa có (thường MongoDB tự tạo)
        // Nhưng đảm bảo performance cho cache key lookups
        <span class="cov8" title="1">keyIndexModel := mongo.IndexModel{
                Keys: bson.D{
                        {Key: "_id", Value: 1},
                },
                Options: options.Index().
                        SetName("cache_key_index"),
        }

        _, err = d.collection.Indexes().CreateOne(ctx, keyIndexModel)
        if err != nil </span><span class="cov0" title="0">{
                // Ignore error nếu index đã tồn tại
                if !mongo.IsDuplicateKeyError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Get lấy một giá trị từ cache.
//
// Phương thức này tìm kiếm document theo key trong MongoDB collection
// và giải mã dữ liệu. Nếu document không tồn tại hoặc đã hết hạn, phương thức
// trả về false ở giá trị thứ hai và cập nhật bộ đếm miss. Nếu tìm thấy và
// còn hạn, phương thức trả về giá trị và cập nhật bộ đếm hit.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần tìm
//
// Returns:
//   - interface{}: Giá trị được lưu trong cache (nil nếu không tìm thấy)
//   - bool: true nếu tìm thấy key và chưa hết hạn, false nếu ngược lại
func (d *mongoDBDriver) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        var cacheItem MongoCacheItem
        err := d.collection.FindOne(ctx, bson.M{"_id": key}).Decode(&amp;cacheItem)

        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        d.config.Misses++
                        return nil, false
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }

        // Kiểm tra expiration (TTL index sẽ tự động xóa expired documents,
        // nhưng chúng ta vẫn kiểm tra để đảm bảo tính nhất quán)
        <span class="cov8" title="1">if cacheItem.Expiration &gt; 0 &amp;&amp; time.Now().UnixNano() &gt; cacheItem.Expiration </span><span class="cov8" title="1">{
                d.config.Misses++
                // TTL index sẽ tự động xóa, không cần xóa thủ công
                return nil, false
        }</span>

        <span class="cov8" title="1">d.config.Hits++
        return cacheItem.Value, true</span>
}

// Set đặt một giá trị vào cache với TTL tùy chọn.
//
// Phương thức này tạo hoặc cập nhật một document trong MongoDB collection
// để lưu trữ cặp key-value với thời gian sống được chỉ định. Nếu key đã tồn tại,
// document cũ sẽ bị thay thế.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key để lưu giá trị
//   - value: Giá trị cần lưu trữ
//   - ttl: Thời gian sống của giá trị (0 để sử dụng mặc định, -1 để không hết hạn)
//
// Returns:
//   - error: Lỗi nếu có trong quá trình lưu trữ vào MongoDB
func (d *mongoDBDriver) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        var exp int64
        now := time.Now()

        if ttl == 0 </span><span class="cov8" title="1">{
                if d.config.GetDefaultExpiration() &gt; 0 </span><span class="cov8" title="1">{
                        exp = now.Add(d.config.GetDefaultExpiration()).UnixNano()
                }</span>
        } else<span class="cov8" title="1"> if ttl &gt; 0 </span><span class="cov8" title="1">{
                exp = now.Add(ttl).UnixNano()
        }</span>

        // Tạo cache item
        <span class="cov8" title="1">cacheItem := MongoCacheItem{
                Key:        key,
                Value:      value,
                Expiration: exp,
                CreatedAt:  now,
        }

        // Nếu có expiration &gt; 0, đặt thời gian hết hạn
        opts := options.ReplaceOptions{}
        opts.SetUpsert(true)

        // Lưu vào MongoDB
        _, err := d.collection.ReplaceOne(
                ctx,
                bson.M{"_id": key},
                cacheItem,
                &amp;opts,
        )

        return err</span>
}

// Has kiểm tra xem một key có tồn tại trong cache không.
//
// Phương thức này xác định liệu một key có tồn tại trong cache và chưa hết hạn hay không.
// Nó sử dụng phương thức Get để thực hiện kiểm tra và do đó cũng cập nhật bộ đếm hit/miss.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần kiểm tra
//
// Returns:
//   - bool: true nếu key tồn tại và chưa hết hạn, false nếu ngược lại
func (d *mongoDBDriver) Has(ctx context.Context, key string) bool <span class="cov8" title="1">{
        _, exists := d.Get(ctx, key)
        return exists
}</span>

// Delete xóa một key khỏi cache.
//
// Phương thức này xóa document tương ứng với key được chỉ định khỏi MongoDB collection.
// Nếu key không tồn tại, thao tác này không có tác dụng và không trả về lỗi.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa
func (d *mongoDBDriver) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        _, err := d.collection.DeleteOne(ctx, bson.M{"_id": key})
        return err
}</span>

// Flush xóa tất cả các key khỏi cache.
//
// Phương thức này xóa tất cả documents trong MongoDB collection,
// làm trống hoàn toàn bộ nhớ cache.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa
func (d *mongoDBDriver) Flush(ctx context.Context) error <span class="cov8" title="1">{
        _, err := d.collection.DeleteMany(ctx, bson.M{})
        return err
}</span>

// GetMultiple lấy nhiều giá trị từ cache.
//
// Phương thức này tìm kiếm và trả về nhiều giá trị từ cache dựa trên danh sách key.
// Các key không tìm thấy hoặc đã hết hạn sẽ được thêm vào danh sách missed.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần lấy
//
// Returns:
//   - map[string]interface{}: Map chứa các key tìm thấy và giá trị tương ứng
//   - []string: Danh sách các key không tìm thấy hoặc đã hết hạn
func (d *mongoDBDriver) GetMultiple(ctx context.Context, keys []string) (map[string]interface{}, []string) <span class="cov8" title="1">{
        results := make(map[string]interface{})
        missed := make([]string, 0)

        // Tạo filter cho nhiều key
        filter := bson.M{"_id": bson.M{"$in": keys}}

        // Tìm tất cả các document khớp với filter
        cursor, err := d.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return results, keys
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        // Tạo map để theo dõi các key đã tìm thấy
        found := make(map[string]bool)
        now := time.Now().UnixNano()

        // Giải mã các kết quả
        for cursor.Next(ctx) </span><span class="cov8" title="1">{
                var cacheItem MongoCacheItem
                if err := cursor.Decode(&amp;cacheItem); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Kiểm tra expiration
                <span class="cov8" title="1">if cacheItem.Expiration &gt; 0 &amp;&amp; now &gt; cacheItem.Expiration </span><span class="cov0" title="0">{
                        missed = append(missed, cacheItem.Key)
                        continue</span>
                }

                <span class="cov8" title="1">results[cacheItem.Key] = cacheItem.Value
                found[cacheItem.Key] = true</span>
        }

        // Thêm các key không tìm thấy vào danh sách missed
        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                if !found[key] </span><span class="cov8" title="1">{
                        missed = append(missed, key)
                }</span>
        }

        <span class="cov8" title="1">return results, missed</span>
}

// SetMultiple đặt nhiều giá trị vào cache.
//
// Phương thức này lưu trữ nhiều cặp key-value vào MongoDB collection trong một lần gọi
// với cùng một thời gian sống. Nó sử dụng BulkWrite để tối ưu hiệu suất.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - values: Map chứa các key và giá trị tương ứng cần lưu trữ
//   - ttl: Thời gian sống chung cho tất cả các giá trị
//
// Returns:
//   - error: Lỗi nếu có trong quá trình lưu trữ
func (d *mongoDBDriver) SetMultiple(ctx context.Context, values map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        if ttl == 0 </span><span class="cov8" title="1">{
                ttl = d.config.GetDefaultExpiration()
        }</span>
        // Chuẩn bị các document để chèn
        <span class="cov8" title="1">now := time.Now()
        exp := now.Add(ttl).UnixNano()

        var operations []mongo.WriteModel

        for key, value := range values </span><span class="cov8" title="1">{
                cacheItem := MongoCacheItem{
                        Key:        key,
                        Value:      value,
                        Expiration: exp,
                        CreatedAt:  now,
                }

                operation := mongo.NewReplaceOneModel().
                        SetFilter(bson.M{"_id": key}).
                        SetReplacement(cacheItem).
                        SetUpsert(true)

                operations = append(operations, operation)
        }</span>

        // Thực hiện bulk write
        <span class="cov8" title="1">_, err := d.collection.BulkWrite(ctx, operations)
        return err</span>
}

// DeleteMultiple xóa nhiều key khỏi cache.
//
// Phương thức này xóa nhiều key và giá trị tương ứng khỏi MongoDB collection trong một lần gọi.
// Nó sử dụng một single query với $in operator để tối ưu hiệu suất.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - keys: Danh sách các khóa cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa
func (d *mongoDBDriver) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Xóa tất cả các document với key trong danh sách
        <span class="cov8" title="1">_, err := d.collection.DeleteMany(ctx, bson.M{"_id": bson.M{"$in": keys}})
        return err</span>
}

// Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy.
//
// Phương thức này kiểm tra xem một key có tồn tại trong cache không, nếu có thì
// trả về giá trị tương ứng. Nếu key không tồn tại hoặc đã hết hạn, phương thức
// sẽ gọi hàm callback để lấy dữ liệu, lưu kết quả vào cache và trả về giá trị đó.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần tìm hoặc lưu vào cache
//   - ttl: Thời gian sống của giá trị nếu phải lấy từ callback
//   - callback: Hàm được gọi để lấy dữ liệu khi key không có trong cache
//
// Returns:
//   - interface{}: Giá trị từ cache hoặc từ callback
//   - error: Lỗi nếu có trong quá trình thực hiện hoặc từ callback
func (d *mongoDBDriver) Remember(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        // Kiểm tra cache trước
        value, found := d.Get(ctx, key)
        if found </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        // Không tìm thấy, gọi callback
        <span class="cov8" title="1">value, err := callback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Lưu kết quả vào cache
        <span class="cov8" title="1">err = d.Set(ctx, key, value, ttl)
        return value, err</span>
}

// Stats trả về thông tin thống kê về cache.
//
// Phương thức này thu thập và trả về các thông tin thống kê về trạng thái
// hiện tại của MongoDB cache như số lượng document, kích thước, số lần hit/miss, v.v.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - map[string]interface{}: Map chứa các thông tin thống kê
func (d *mongoDBDriver) Stats(ctx context.Context) map[string]interface{} <span class="cov8" title="1">{
        // Đếm số lượng document
        count, err := d.collection.CountDocuments(ctx, bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                count = -1
        }</span>

        // Lấy stats từ cơ sở dữ liệu
        <span class="cov8" title="1">var stats bson.M
        cmd := bson.D{{Key: "collStats", Value: d.collection.Name()}}
        err = d.database.RunCommand(ctx, cmd).Decode(&amp;stats)
        if err != nil </span><span class="cov0" title="0">{
                stats = bson.M{}
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "count":  count,
                "hits":   d.config.Hits,
                "misses": d.config.Misses,
                "type":   "mongodb",
                "stats":  stats,
        }</span>
}

// Close giải phóng tài nguyên của driver.
//
// Phương thức này đóng kết nối tới MongoDB và giải phóng
// các tài nguyên khác được sử dụng bởi driver.
//
// Returns:
//   - error: Lỗi nếu có trong quá trình đóng kết nối
func (d *mongoDBDriver) Close() error <span class="cov8" title="1">{
        // disconnect MongoDB connection by service provider mongodb
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package driver

import (
        "bytes"
        "context"
        "encoding/gob"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/vmihailenco/msgpack/v5"
        "go.fork.vn/cache/config"
        redisManager "go.fork.vn/redis"
)

type RedisDriver interface {
        Driver
        WithSerializer(serializer string) RedisDriver
}

// redisDriver cài đặt cache driver sử dụng Redis.
//
// redisDriver lưu trữ dữ liệu cache trong Redis, một hệ thống lưu trữ key-value
// có tính năng persistence và phân tán. Driver này phù hợp cho các ứng dụng yêu cầu
// khả năng mở rộng, phân tán cache giữa nhiều instance ứng dụng và khả năng phục hồi
// sau khi khởi động lại. Nó cũng tận dụng các tính năng của Redis như key expiration.
type redisDriver struct {
        client       *redis.Client                     // Redis client để giao tiếp với Redis server
        prefix       string                            // Tiền tố cho các key cache để tránh xung đột
        default_ttl  time.Duration                     // Thời gian sống mặc định cho các entry không chỉ định TTL
        serializer   func(interface{}) ([]byte, error) // Hàm serialization để chuyển đổi giá trị thành dạng binary
        deserializer func([]byte, interface{}) error   // Hàm deserialization để chuyển đổi từ binary
        hits         int64                             // Số lần cache hit
        misses       int64                             // Số lần cache miss
}

// NewRedisDriver tạo một Redis driver mới với cấu hình mặc định.
//
// Phương thức này khởi tạo một RedisDriver mới với thông tin kết nối cơ bản.
// Nó sử dụng cấu hình mặc định cho prefix là "cache:" và default_ttl là 5 phút.
//
// Params:
//   - host: Hostname hoặc IP của Redis server
//   - port: Port của Redis server
//   - password: Mật khẩu xác thực (empty string nếu không cần)
//   - db: Database index để sử dụng
//
// Returns:
//   - *RedisDriver: Driver đã được khởi tạo
//   - error: Lỗi nếu không thể kết nối tới Redis server
func NewRedisDriver(config config.DriverRedisConfig, redis_manager redisManager.Manager) (RedisDriver, error) <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis driver is not enabled")
        }</span>
        <span class="cov0" title="0">client, err := redis_manager.Client()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not create Redis client: %w", err)
        }</span>
        // Khởi tạo driver
        <span class="cov0" title="0">driver := &amp;redisDriver{
                client:       client,
                prefix:       "cache:", // Tiền tố mặc định
                default_ttl:  time.Duration(config.DefaultTTL) * time.Second,
                serializer:   json.Marshal,
                deserializer: json.Unmarshal,
                hits:         0,
                misses:       0,
        }
        switch config.Serializer </span>{

        case "gob":<span class="cov0" title="0">
                driver.serializer = func(v interface{}) ([]byte, error) </span><span class="cov0" title="0">{
                        var buf bytes.Buffer
                        enc := gob.NewEncoder(&amp;buf)
                        if err := enc.Encode(v); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not serialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return buf.Bytes(), nil</span>
                }
                <span class="cov0" title="0">driver.deserializer = func(data []byte, v interface{}) error </span><span class="cov0" title="0">{
                        buf := bytes.NewBuffer(data)
                        dec := gob.NewDecoder(buf)
                        if err := dec.Decode(v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not deserialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        case "msgpack":<span class="cov0" title="0">
                driver.serializer = func(v interface{}) ([]byte, error) </span><span class="cov0" title="0">{
                        data, err := msgpack.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not serialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return data, nil</span>
                }
                <span class="cov0" title="0">driver.deserializer = func(data []byte, v interface{}) error </span><span class="cov0" title="0">{
                        if err := msgpack.Unmarshal(data, v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not deserialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        default:<span class="cov0" title="0">
                driver.serializer = json.Marshal
                driver.deserializer = json.Unmarshal</span>
        }
        <span class="cov0" title="0">return driver, nil</span>
}

// prefixKey thêm prefix vào key.
//
// Phương thức này thêm tiền tố đã cấu hình vào cache key để tạo thành Redis key hoàn chỉnh.
// Việc này giúp tránh xung đột với các key khác trong cùng một Redis database.
//
// Params:
//   - key: Cache key cần thêm tiền tố
//
// Returns:
//   - string: Redis key đã được thêm tiền tố
func (d *redisDriver) prefixKey(key string) string <span class="cov0" title="0">{
        return d.prefix + key
}</span>

// Get lấy một giá trị từ cache.
func (d *redisDriver) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov0" title="0">{
        prefixedKey := d.prefixKey(key)

        // Lấy giá trị từ Redis
        data, err := d.client.Get(ctx, prefixedKey).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        // Key không tồn tại
                        d.misses++
                        return nil, false
                }</span>
                // Lỗi khác
                <span class="cov0" title="0">return nil, false</span>
        }
        // Giải mã dữ liệu - cần xử lý khác nhau tùy theo serializer
        <span class="cov0" title="0">var value interface{}

        // For GOB and MSGPACK, we need to decode differently
        if d.deserializer != nil </span><span class="cov0" title="0">{
                // Create a buffer to hold the decoded value
                var decodedValue interface{}
                if err := d.deserializer(data, &amp;decodedValue); err != nil </span><span class="cov0" title="0">{
                        d.misses++
                        return nil, false
                }</span>
                <span class="cov0" title="0">value = decodedValue</span>
        } else<span class="cov0" title="0"> {
                // Fallback to JSON
                if err := json.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                        d.misses++
                        return nil, false
                }</span>
        }

        <span class="cov0" title="0">d.hits++
        return value, true</span>
}

// Set đặt một giá trị vào cache với TTL tùy chọn.
//
// Phương thức này mã hóa và lưu trữ một cặp key-value vào Redis với thời gian sống
// được chỉ định. Nếu key đã tồn tại, giá trị sẽ bị ghi đè.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key để lưu giá trị
//   - value: Giá trị cần lưu trữ
//   - ttl: Thời gian sống của giá trị (0 để sử dụng mặc định, -1 để không hết hạn)
//
// Returns:
//   - error: Lỗi nếu có trong quá trình mã hóa hoặc lưu trữ
func (d *redisDriver) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        prefixedKey := d.prefixKey(key)

        // Mã hóa dữ liệu
        data, err := d.serializer(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not serialize value: %w", err)
        }</span>

        // Xác định thời gian hết hạn
        <span class="cov0" title="0">if ttl == 0 </span><span class="cov0" title="0">{
                ttl = d.default_ttl
        }</span>

        // Lưu vào Redis
        <span class="cov0" title="0">return d.client.Set(ctx, prefixedKey, data, ttl).Err()</span>
}

// Has kiểm tra xem một key có tồn tại trong cache không.
//
// Phương thức này kiểm tra sự tồn tại của key trong Redis bằng cách
// sử dụng lệnh EXISTS của Redis.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần kiểm tra
//
// Returns:
//   - bool: true nếu key tồn tại, false nếu ngược lại
func (d *redisDriver) Has(ctx context.Context, key string) bool <span class="cov0" title="0">{
        prefixedKey := d.prefixKey(key)
        exists, _ := d.client.Exists(ctx, prefixedKey).Result()
        return exists &gt; 0
}</span>

// Delete xóa một key khỏi cache.
//
// Phương thức này xóa key và giá trị tương ứng khỏi Redis nếu tồn tại.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//   - key: Cache key cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa
func (d *redisDriver) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        prefixedKey := d.prefixKey(key)
        return d.client.Del(ctx, prefixedKey).Err()
}</span>

// Flush xóa tất cả các key khỏi cache có prefix đã định.
//
// Phương thức này quét và xóa tất cả các key có tiền tố đã cấu hình
// trong Redis database được sử dụng. Phương pháp này an toàn hơn so với
// FLUSHDB vì nó chỉ xóa các key thuộc về cache này.
//
// Params:
//   - ctx: Context để kiểm soát thời gian thực thi của thao tác
//
// Returns:
//   - error: Lỗi nếu có trong quá trình quét hoặc xóa
func (d *redisDriver) Flush(ctx context.Context) error <span class="cov0" title="0">{
        // Tìm tất cả các key có prefix
        pattern := d.prefix + "*"
        iter := d.client.Scan(ctx, 0, pattern, 0).Iterator()

        // Xóa từng key
        var keys []string
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                keys = append(keys, iter.Val())

                // Xóa theo batch để tối ưu hiệu suất
                if len(keys) &gt;= 100 </span><span class="cov0" title="0">{
                        if err := d.client.Del(ctx, keys...).Err(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">keys = []string{}</span>
                }
        }

        // Xóa batch cuối cùng
        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                return d.client.Del(ctx, keys...).Err()
        }</span>

        <span class="cov0" title="0">return iter.Err()</span>
}

// GetMultiple lấy nhiều giá trị từ cache
func (d *redisDriver) GetMultiple(ctx context.Context, keys []string) (map[string]interface{}, []string) <span class="cov0" title="0">{
        results := make(map[string]interface{})
        missed := make([]string, 0)

        // Chuẩn bị các key với prefix
        prefixedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                prefixedKeys[i] = d.prefixKey(key)
        }</span>

        // Sử dụng MGET để lấy nhiều giá trị cùng lúc
        <span class="cov0" title="0">values, err := d.client.MGet(ctx, prefixedKeys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                // Lỗi, trả về tất cả keys là missed
                return results, keys
        }</span>

        // Xử lý kết quả
        <span class="cov0" title="0">for i, value := range values </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        missed = append(missed, keys[i])
                        continue</span>
                }

                // Giải mã dữ liệu
                <span class="cov0" title="0">var decoded interface{}
                data, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        missed = append(missed, keys[i])
                        continue</span>
                }

                // Use the same deserialization logic as Get method
                <span class="cov0" title="0">if d.deserializer != nil </span><span class="cov0" title="0">{
                        if err := d.deserializer([]byte(data), &amp;decoded); err != nil </span><span class="cov0" title="0">{
                                missed = append(missed, keys[i])
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        if err := json.Unmarshal([]byte(data), &amp;decoded); err != nil </span><span class="cov0" title="0">{
                                missed = append(missed, keys[i])
                                continue</span>
                        }
                }

                <span class="cov0" title="0">results[keys[i]] = decoded</span>
        }

        <span class="cov0" title="0">return results, missed</span>
}

// SetMultiple đặt nhiều giá trị vào cache
func (d *redisDriver) SetMultiple(ctx context.Context, values map[string]interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = d.default_ttl
        }</span>

        // Sử dụng pipe để tối ưu hiệu suất
        <span class="cov0" title="0">pipe := d.client.Pipeline()

        for key, value := range values </span><span class="cov0" title="0">{
                // Mã hóa dữ liệu
                data, err := d.serializer(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not serialize value for key '%s': %w", key, err)
                }</span>

                <span class="cov0" title="0">prefixedKey := d.prefixKey(key)
                pipe.Set(ctx, prefixedKey, data, ttl)</span>
        }

        // Thực thi pipeline
        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        return err</span>
}

// DeleteMultiple xóa nhiều key khỏi cache
func (d *redisDriver) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Chuẩn bị các key với prefix
        <span class="cov0" title="0">prefixedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                prefixedKeys[i] = d.prefixKey(key)
        }</span>

        // Xóa tất cả các key cùng lúc
        <span class="cov0" title="0">return d.client.Del(ctx, prefixedKeys...).Err()</span>
}

// Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy
func (d *redisDriver) Remember(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        // Kiểm tra cache trước
        value, found := d.Get(ctx, key)
        if found </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // Không tìm thấy, gọi callback
        <span class="cov0" title="0">value, err := callback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Lưu kết quả vào cache
        <span class="cov0" title="0">err = d.Set(ctx, key, value, ttl)
        return value, err</span>
}

// Stats trả về thông tin thống kê về cache
func (d *redisDriver) Stats(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        // Đếm số lượng key với prefix
        pattern := d.prefix + "*"
        count, err := d.client.Keys(ctx, pattern).Result()
        countVal := len(count)
        if err != nil </span><span class="cov0" title="0">{
                countVal = -1
        }</span>

        // Lấy thông tin từ INFO command
        <span class="cov0" title="0">info, err := d.client.Info(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                info = ""
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "count":  countVal,
                "hits":   d.hits,
                "misses": d.misses,
                "type":   "redis",
                "prefix": d.prefix,
                "info":   info,
        }</span>
}

// Close giải phóng tài nguyên của driver
func (d *redisDriver) Close() error <span class="cov0" title="0">{
        return d.client.Close()
}</span>

// WithSerializer thiết lập serializer theo tên
func (d *redisDriver) WithSerializer(serializerName string) RedisDriver <span class="cov0" title="0">{
        newDriver := &amp;redisDriver{
                client:      d.client,
                prefix:      d.prefix,
                default_ttl: d.default_ttl,
                hits:        d.hits,
                misses:      d.misses,
        }

        switch serializerName </span>{
        case "gob":<span class="cov0" title="0">
                newDriver.serializer = func(v interface{}) ([]byte, error) </span><span class="cov0" title="0">{
                        var buf bytes.Buffer
                        enc := gob.NewEncoder(&amp;buf)
                        if err := enc.Encode(v); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not serialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return buf.Bytes(), nil</span>
                }
                <span class="cov0" title="0">newDriver.deserializer = func(data []byte, v interface{}) error </span><span class="cov0" title="0">{
                        buf := bytes.NewBuffer(data)
                        dec := gob.NewDecoder(buf)
                        if err := dec.Decode(v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not deserialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        case "msgpack":<span class="cov0" title="0">
                newDriver.serializer = func(v interface{}) ([]byte, error) </span><span class="cov0" title="0">{
                        data, err := msgpack.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not serialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return data, nil</span>
                }
                <span class="cov0" title="0">newDriver.deserializer = func(data []byte, v interface{}) error </span><span class="cov0" title="0">{
                        if err := msgpack.Unmarshal(data, v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not deserialize value: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        default:<span class="cov0" title="0"> // json
                newDriver.serializer = json.Marshal
                newDriver.deserializer = json.Unmarshal</span>
        }

        <span class="cov0" title="0">return newDriver</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.fork.vn/cache/driver"
)

// Manager là interface chính để quản lý các driver cache.
//
// Manager cung cấp một lớp trừu tượng để làm việc với nhiều cache driver khác nhau.
// Nó cho phép đăng ký nhiều driver dựa trên tên và đặt một driver mặc định
// để sử dụng cho các thao tác cache. Nó cũng cung cấp các phương thức tiện ích
// cho tất cả các thao tác cơ bản trên cache mà không cần trực tiếp tương tác với driver.
type Manager interface {
        // Get lấy một giá trị từ cache.
        //
        // Phương thức này tìm kiếm và trả về giá trị từ cache mặc định dựa trên key được cung cấp.
        //
        // Params:
        //   - key: Cache key cần tìm
        //
        // Returns:
        //   - interface{}: Giá trị được lưu trong cache (nil nếu không tìm thấy)
        //   - bool: true nếu tìm thấy key và chưa hết hạn, false nếu ngược lại
        Get(key string) (interface{}, bool)

        // Set đặt một giá trị vào cache với TTL tùy chọn.
        //
        // Phương thức này lưu trữ một cặp key-value vào cache mặc định với thời gian sống
        // được chỉ định. Nếu key đã tồn tại, giá trị sẽ bị ghi đè.
        //
        // Params:
        //   - key: Cache key để lưu giá trị
        //   - value: Giá trị cần lưu trữ
        //   - ttl: Thời gian sống của giá trị (0 để sử dụng mặc định của driver, -1 để không hết hạn)
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình lưu trữ hoặc driver mặc định không được cấu hình
        Set(key string, value interface{}, ttl time.Duration) error

        // Has kiểm tra xem một key có tồn tại trong cache không.
        //
        // Phương thức này xác định liệu một key có tồn tại trong cache mặc định và chưa hết hạn hay không.
        //
        // Params:
        //   - key: Cache key cần kiểm tra
        //
        // Returns:
        //   - bool: true nếu key tồn tại và chưa hết hạn, false nếu ngược lại
        Has(key string) bool

        // Delete xóa một key khỏi cache.
        //
        // Phương thức này xóa key và giá trị tương ứng khỏi cache mặc định nếu tồn tại.
        //
        // Params:
        //   - key: Cache key cần xóa
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
        Delete(key string) error

        // Flush xóa tất cả các key khỏi cache.
        //
        // Phương thức này xóa tất cả dữ liệu trong cache mặc định, làm trống hoàn toàn bộ nhớ cache.
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
        Flush() error

        // GetMultiple lấy nhiều giá trị từ cache.
        //
        // Phương thức này lấy các giá trị tương ứng với nhiều key từ cache mặc định trong một lần gọi.
        //
        // Params:
        //   - keys: Danh sách các khóa cần lấy
        //
        // Returns:
        //   - map[string]interface{}: Map chứa các key tìm thấy và giá trị tương ứng
        //   - []string: Danh sách các key không tìm thấy hoặc đã hết hạn
        GetMultiple(keys []string) (map[string]interface{}, []string)

        // SetMultiple đặt nhiều giá trị vào cache.
        //
        // Phương thức này lưu trữ nhiều cặp key-value vào cache mặc định trong một lần gọi
        // với cùng một thời gian sống.
        //
        // Params:
        //   - values: Map chứa các key và giá trị tương ứng cần lưu trữ
        //   - ttl: Thời gian sống chung cho tất cả các giá trị
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình lưu trữ hoặc driver mặc định không được cấu hình
        SetMultiple(values map[string]interface{}, ttl time.Duration) error

        // DeleteMultiple xóa nhiều key khỏi cache.
        //
        // Phương thức này xóa nhiều key và giá trị tương ứng khỏi cache mặc định trong một lần gọi.
        //
        // Params:
        //   - keys: Danh sách các khóa cần xóa
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
        DeleteMultiple(keys []string) error

        // Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy.
        //
        // Phương thức này kiểm tra xem một key có tồn tại trong cache mặc định không, nếu có thì
        // trả về giá trị tương ứng. Nếu key không tồn tại hoặc đã hết hạn, phương thức
        // sẽ gọi hàm callback để lấy dữ liệu, lưu kết quả vào cache và trả về giá trị đó.
        //
        // Params:
        //   - key: Cache key cần tìm hoặc lưu vào cache
        //   - ttl: Thời gian sống của giá trị nếu phải lấy từ callback
        //   - callback: Hàm được gọi để lấy dữ liệu khi key không có trong cache
        //
        // Returns:
        //   - interface{}: Giá trị từ cache hoặc từ callback
        //   - error: Lỗi nếu có trong quá trình thực hiện, từ callback, hoặc driver mặc định không được cấu hình
        Remember(key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error)

        // AddDriver thêm một driver vào manager.
        //
        // Phương thức này đăng ký một driver mới với manager theo tên xác định.
        // Nếu chưa có driver mặc định được đặt, driver đầu tiên được thêm vào sẽ trở thành mặc định.
        //
        // Params:
        //   - name: Tên định danh cho driver
        //   - driver: Đối tượng driver cần thêm vào
        AddDriver(name string, driver driver.Driver)

        // SetDefaultDriver đặt driver mặc định.
        //
        // Phương thức này thiết lập driver mặc định được sử dụng cho các thao tác cache.
        // Driver phải đã được đăng ký với manager trước đó.
        //
        // Params:
        //   - name: Tên của driver cần đặt làm mặc định
        SetDefaultDriver(name string)

        // Driver trả về một driver cụ thể theo tên.
        //
        // Phương thức này lấy một driver đã đăng ký dựa theo tên của nó.
        //
        // Params:
        //   - name: Tên của driver cần lấy
        //
        // Returns:
        //   - driver.Driver: Đối tượng driver được yêu cầu
        //   - error: Lỗi nếu driver không tồn tại
        Driver(name string) (driver.Driver, error)

        // Stats trả về thông tin thống kê về tất cả các driver.
        //
        // Phương thức này thu thập và trả về các thông tin thống kê về trạng thái hiện tại
        // của tất cả các driver đã đăng ký.
        //
        // Returns:
        //   - map[string]map[string]interface{}: Map chứa thông tin thống kê của từng driver, với key là tên driver
        Stats() map[string]map[string]interface{}

        // Close đóng tất cả các driver.
        //
        // Phương thức này giải phóng tài nguyên của tất cả các driver đã đăng ký.
        //
        // Returns:
        //   - error: Lỗi nếu có trong quá trình đóng bất kỳ driver nào
        Close() error
}

// manager là implementation mặc định của Manager.
//
// manager quản lý nhiều driver cache thông qua một map driver và cung cấp
// cơ chế để thực hiện các thao tác cache qua driver mặc định. Nó đảm bảo thread-safety
// thông qua RWMutex và cung cấp các phương thức tiện ích để tương tác với nhiều driver.
type manager struct {
        drivers       map[string]driver.Driver // Map chứa tất cả các driver đã đăng ký
        defaultDriver string                   // Tên của driver mặc định
        mu            sync.RWMutex             // Mutex cho các thao tác thread-safe
}

// NewManager tạo một manager mới.
//
// Phương thức này khởi tạo một DefaultManager mới, sẵn sàng để đăng ký các driver.
//
// Returns:
//   - Manager: Đối tượng Manager mới được khởi tạo
func NewManager() Manager <span class="cov8" title="1">{
        return &amp;manager{
                drivers: make(map[string]driver.Driver),
        }
}</span>

// Get lấy một giá trị từ cache.
//
// Phương thức này tìm kiếm và trả về giá trị từ cache mặc định dựa trên key được cung cấp.
//
// Params:
//   - key: Cache key cần tìm
//
// Returns:
//   - interface{}: Giá trị được lưu trong cache (nil nếu không tìm thấy)
//   - bool: true nếu tìm thấy key và chưa hết hạn, false nếu ngược lại
func (m *manager) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return driver.Get(context.Background(), key)</span>
}

// Set đặt một giá trị vào cache với TTL tùy chọn.
//
// Phương thức này lưu trữ một cặp key-value vào cache mặc định với thời gian sống được chỉ định.
//
// Params:
//   - key: Cache key để lưu giá trị
//   - value: Giá trị cần lưu trữ
//   - ttl: Thời gian sống của giá trị
//
// Returns:
//   - error: Lỗi nếu có trong quá trình lưu trữ hoặc driver mặc định không được cấu hình
func (m *manager) Set(key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.Set(context.Background(), key, value, ttl)</span>
}

// Has kiểm tra xem một key có tồn tại trong cache không.
//
// Phương thức này xác định liệu một key có tồn tại trong cache mặc định và chưa hết hạn hay không.
//
// Params:
//   - key: Cache key cần kiểm tra
//
// Returns:
//   - bool: true nếu key tồn tại và chưa hết hạn, false nếu ngược lại
func (m *manager) Has(key string) bool <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return driver.Has(context.Background(), key)</span>
}

// Delete xóa một key khỏi cache.
//
// Phương thức này xóa key và giá trị tương ứng khỏi cache mặc định nếu tồn tại.
//
// Params:
//   - key: Cache key cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
func (m *manager) Delete(key string) error <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.Delete(context.Background(), key)</span>
}

// Flush xóa tất cả các key khỏi cache.
//
// Phương thức này xóa tất cả dữ liệu trong cache mặc định, làm trống hoàn toàn bộ nhớ cache.
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
func (m *manager) Flush() error <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.Flush(context.Background())</span>
}

// GetMultiple lấy nhiều giá trị từ cache.
//
// Phương thức này lấy các giá trị tương ứng với nhiều key từ cache mặc định trong một lần gọi.
//
// Params:
//   - keys: Danh sách các khóa cần lấy
//
// Returns:
//   - map[string]interface{}: Map chứa các key tìm thấy và giá trị tương ứng
//   - []string: Danh sách các key không tìm thấy hoặc đã hết hạn
func (m *manager) GetMultiple(keys []string) (map[string]interface{}, []string) <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return make(map[string]interface{}), keys
        }</span>
        <span class="cov8" title="1">return driver.GetMultiple(context.Background(), keys)</span>
}

// SetMultiple đặt nhiều giá trị vào cache.
//
// Phương thức này lưu trữ nhiều cặp key-value vào cache mặc định trong một lần gọi
// với cùng một thời gian sống.
//
// Params:
//   - values: Map chứa các key và giá trị tương ứng cần lưu trữ
//   - ttl: Thời gian sống chung cho tất cả các giá trị
//
// Returns:
//   - error: Lỗi nếu có trong quá trình lưu trữ hoặc driver mặc định không được cấu hình
func (m *manager) SetMultiple(values map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.SetMultiple(context.Background(), values, ttl)</span>
}

// DeleteMultiple xóa nhiều key khỏi cache.
//
// Phương thức này xóa nhiều key và giá trị tương ứng khỏi cache mặc định trong một lần gọi.
//
// Params:
//   - keys: Danh sách các khóa cần xóa
//
// Returns:
//   - error: Lỗi nếu có trong quá trình xóa hoặc driver mặc định không được cấu hình
func (m *manager) DeleteMultiple(keys []string) error <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.DeleteMultiple(context.Background(), keys)</span>
}

// Remember lấy một giá trị từ cache hoặc thực thi callback nếu không tìm thấy.
//
// Phương thức này kiểm tra xem một key có tồn tại trong cache mặc định không, nếu có thì
// trả về giá trị tương ứng. Nếu key không tồn tại hoặc đã hết hạn, phương thức
// sẽ gọi hàm callback để lấy dữ liệu, lưu kết quả vào cache và trả về giá trị đó.
//
// Params:
//   - key: Cache key cần tìm hoặc lưu vào cache
//   - ttl: Thời gian sống của giá trị nếu phải lấy từ callback
//   - callback: Hàm được gọi để lấy dữ liệu khi key không có trong cache
//
// Returns:
//   - interface{}: Giá trị từ cache hoặc từ callback
//   - error: Lỗi nếu có trong quá trình thực hiện, từ callback, hoặc driver mặc định không được cấu hình
func (m *manager) Remember(key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        driver, err := m.DefaultDriver()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return driver.Remember(context.Background(), key, ttl, callback)</span>
}

// AddDriver thêm một driver vào manager.
//
// Phương thức này đăng ký một driver mới với manager theo tên xác định.
// Nếu chưa có driver mặc định được đặt, driver đầu tiên được thêm vào sẽ trở thành mặc định.
//
// Params:
//   - name: Tên định danh cho driver
//   - driver: Đối tượng driver cần thêm vào
func (m *manager) AddDriver(name string, driver driver.Driver) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.drivers[name] = driver

        // Đặt driver đầu tiên được thêm làm mặc định nếu chưa có driver mặc định
        if m.defaultDriver == "" </span><span class="cov8" title="1">{
                m.defaultDriver = name
        }</span>
}

// SetDefaultDriver đặt driver mặc định.
//
// Phương thức này thiết lập driver mặc định được sử dụng cho các thao tác cache.
// Driver phải đã được đăng ký với manager trước đó.
//
// Params:
//   - name: Tên của driver cần đặt làm mặc định
func (m *manager) SetDefaultDriver(name string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.drivers[name]; ok </span><span class="cov8" title="1">{
                m.defaultDriver = name
        }</span>
}

// Driver trả về một driver cụ thể theo tên.
//
// Phương thức này lấy một driver đã đăng ký dựa theo tên của nó.
//
// Params:
//   - name: Tên của driver cần lấy
//
// Returns:
//   - driver.Driver: Đối tượng driver được yêu cầu
//   - error: Lỗi nếu driver không tồn tại
func (m *manager) Driver(name string) (driver.Driver, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if driver, ok := m.drivers[name]; ok </span><span class="cov8" title="1">{
                return driver, nil
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("cache driver '%s' not found", name)</span>
}

// Stats trả về thông tin thống kê về tất cả các driver.
//
// Phương thức này thu thập và trả về các thông tin thống kê về trạng thái hiện tại
// của tất cả các driver đã đăng ký.
//
// Returns:
//   - map[string]map[string]interface{}: Map chứa thông tin thống kê của từng driver, với key là tên driver
func (m *manager) Stats() map[string]map[string]interface{} <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := make(map[string]map[string]interface{})
        for name, driver := range m.drivers </span><span class="cov8" title="1">{
                stats[name] = driver.Stats(context.Background())
        }</span>
        <span class="cov8" title="1">return stats</span>
}

// Close đóng tất cả các driver.
//
// Phương thức này giải phóng tài nguyên của tất cả các driver đã đăng ký.
//
// Returns:
//   - error: Lỗi nếu có trong quá trình đóng bất kỳ driver nào
func (m *manager) Close() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        var firstErr error
        for name, driver := range m.drivers </span><span class="cov8" title="1">{
                if err := driver.Close(); err != nil &amp;&amp; firstErr == nil </span><span class="cov8" title="1">{
                        firstErr = fmt.Errorf("failed to close cache driver '%s': %w", name, err)
                }</span>
        }
        <span class="cov8" title="1">return firstErr</span>
}

// DefaultDriver trả về driver mặc định.
//
// Phương thức này lấy driver mặc định hiện tại từ manager, kiểm tra tính hợp lệ
// và trả về lỗi nếu không có driver mặc định hoặc driver đã bị xóa.
//
// Returns:
//   - driver.Driver: Đối tượng driver mặc định
//   - error: Lỗi nếu không có driver mặc định hoặc driver mặc định không tồn tại
func (m *manager) DefaultDriver() (driver.Driver, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.defaultDriver == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no default cache driver set")
        }</span>

        <span class="cov8" title="1">if driver, ok := m.drivers[m.defaultDriver]; ok </span><span class="cov8" title="1">{
                return driver, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("default cache driver '%s' not found", m.defaultDriver)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        time "time"
)

// MockDriver is an autogenerated mock type for the Driver type
type MockDriver struct {
        mock.Mock
}

type MockDriver_Expecter struct {
        mock *mock.Mock
}

func (_m *MockDriver) EXPECT() *MockDriver_Expecter <span class="cov8" title="1">{
        return &amp;MockDriver_Expecter{mock: &amp;_m.Mock}
}</span>

// Close provides a mock function with no fields
func (_m *MockDriver) Close() error <span class="cov8" title="1">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockDriver_Close_Call struct {
        *mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockDriver_Expecter) Close() *MockDriver_Close_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Close_Call{Call: _e.mock.On("Close")}
}</span>

func (_c *MockDriver_Close_Call) Run(run func()) *MockDriver_Close_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Close_Call) Return(_a0 error) *MockDriver_Close_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Close_Call) RunAndReturn(run func() error) *MockDriver_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: ctx, key
func (_m *MockDriver) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, key)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockDriver_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockDriver_Expecter) Delete(ctx interface{}, key interface{}) *MockDriver_Delete_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Delete_Call{Call: _e.mock.On("Delete", ctx, key)}
}</span>

func (_c *MockDriver_Delete_Call) Run(run func(ctx context.Context, key string)) *MockDriver_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Delete_Call) Return(_a0 error) *MockDriver_Delete_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Delete_Call) RunAndReturn(run func(context.Context, string) error) *MockDriver_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteMultiple provides a mock function with given fields: ctx, keys
func (_m *MockDriver) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, keys)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteMultiple")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, keys)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_DeleteMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMultiple'
type MockDriver_DeleteMultiple_Call struct {
        *mock.Call
}

// DeleteMultiple is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
func (_e *MockDriver_Expecter) DeleteMultiple(ctx interface{}, keys interface{}) *MockDriver_DeleteMultiple_Call <span class="cov8" title="1">{
        return &amp;MockDriver_DeleteMultiple_Call{Call: _e.mock.On("DeleteMultiple", ctx, keys)}
}</span>

func (_c *MockDriver_DeleteMultiple_Call) Run(run func(ctx context.Context, keys []string)) *MockDriver_DeleteMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].([]string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_DeleteMultiple_Call) Return(_a0 error) *MockDriver_DeleteMultiple_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_DeleteMultiple_Call) RunAndReturn(run func(context.Context, []string) error) *MockDriver_DeleteMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Flush provides a mock function with given fields: ctx
func (_m *MockDriver) Flush(ctx context.Context) error <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Flush")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockDriver_Flush_Call struct {
        *mock.Call
}

// Flush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDriver_Expecter) Flush(ctx interface{}) *MockDriver_Flush_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Flush_Call{Call: _e.mock.On("Flush", ctx)}
}</span>

func (_c *MockDriver_Flush_Call) Run(run func(ctx context.Context)) *MockDriver_Flush_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Flush_Call) Return(_a0 error) *MockDriver_Flush_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Flush_Call) RunAndReturn(run func(context.Context) error) *MockDriver_Flush_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Get provides a mock function with given fields: ctx, key
func (_m *MockDriver) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        ret := _m.Called(ctx, key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov8" title="1">var r0 interface{}
        var r1 bool
        if rf, ok := ret.Get(0).(func(context.Context, string) (interface{}, bool)); ok </span><span class="cov0" title="0">{
                return rf(ctx, key)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, key)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(interface{})
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, key)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockDriver_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockDriver_Get_Call struct {
        *mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockDriver_Expecter) Get(ctx interface{}, key interface{}) *MockDriver_Get_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Get_Call{Call: _e.mock.On("Get", ctx, key)}
}</span>

func (_c *MockDriver_Get_Call) Run(run func(ctx context.Context, key string)) *MockDriver_Get_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Get_Call) Return(_a0 interface{}, _a1 bool) *MockDriver_Get_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDriver_Get_Call) RunAndReturn(run func(context.Context, string) (interface{}, bool)) *MockDriver_Get_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetMultiple provides a mock function with given fields: ctx, keys
func (_m *MockDriver) GetMultiple(ctx context.Context, keys []string) (map[string]interface{}, []string) <span class="cov8" title="1">{
        ret := _m.Called(ctx, keys)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMultiple")</span>
        }

        <span class="cov8" title="1">var r0 map[string]interface{}
        var r1 []string
        if rf, ok := ret.Get(0).(func(context.Context, []string) (map[string]interface{}, []string)); ok </span><span class="cov0" title="0">{
                return rf(ctx, keys)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, []string) map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, keys)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[string]interface{})
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, []string) []string); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, keys)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).([]string)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// MockDriver_GetMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMultiple'
type MockDriver_GetMultiple_Call struct {
        *mock.Call
}

// GetMultiple is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
func (_e *MockDriver_Expecter) GetMultiple(ctx interface{}, keys interface{}) *MockDriver_GetMultiple_Call <span class="cov8" title="1">{
        return &amp;MockDriver_GetMultiple_Call{Call: _e.mock.On("GetMultiple", ctx, keys)}
}</span>

func (_c *MockDriver_GetMultiple_Call) Run(run func(ctx context.Context, keys []string)) *MockDriver_GetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].([]string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_GetMultiple_Call) Return(_a0 map[string]interface{}, _a1 []string) *MockDriver_GetMultiple_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDriver_GetMultiple_Call) RunAndReturn(run func(context.Context, []string) (map[string]interface{}, []string)) *MockDriver_GetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Has provides a mock function with given fields: ctx, key
func (_m *MockDriver) Has(ctx context.Context, key string) bool <span class="cov8" title="1">{
        ret := _m.Called(ctx, key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Has")</span>
        }

        <span class="cov8" title="1">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, key)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type MockDriver_Has_Call struct {
        *mock.Call
}

// Has is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockDriver_Expecter) Has(ctx interface{}, key interface{}) *MockDriver_Has_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Has_Call{Call: _e.mock.On("Has", ctx, key)}
}</span>

func (_c *MockDriver_Has_Call) Run(run func(ctx context.Context, key string)) *MockDriver_Has_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Has_Call) Return(_a0 bool) *MockDriver_Has_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Has_Call) RunAndReturn(run func(context.Context, string) bool) *MockDriver_Has_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Remember provides a mock function with given fields: ctx, key, ttl, callback
func (_m *MockDriver) Remember(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, key, ttl, callback)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Remember")</span>
        }

        <span class="cov8" title="1">var r0 interface{}
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, func() (interface{}, error)) (interface{}, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, key, ttl, callback)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, func() (interface{}, error)) interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, key, ttl, callback)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(interface{})
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration, func() (interface{}, error)) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, key, ttl, callback)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockDriver_Remember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remember'
type MockDriver_Remember_Call struct {
        *mock.Call
}

// Remember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - callback func()(interface{} , error)
func (_e *MockDriver_Expecter) Remember(ctx interface{}, key interface{}, ttl interface{}, callback interface{}) *MockDriver_Remember_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Remember_Call{Call: _e.mock.On("Remember", ctx, key, ttl, callback)}
}</span>

func (_c *MockDriver_Remember_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, callback func() (interface{}, error))) *MockDriver_Remember_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(func() (interface{}, error)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Remember_Call) Return(_a0 interface{}, _a1 error) *MockDriver_Remember_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDriver_Remember_Call) RunAndReturn(run func(context.Context, string, time.Duration, func() (interface{}, error)) (interface{}, error)) *MockDriver_Remember_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Set provides a mock function with given fields: ctx, key, value, ttl
func (_m *MockDriver) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, key, value, ttl)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Set")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, key, value, ttl)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockDriver_Set_Call struct {
        *mock.Call
}

// Set is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - ttl time.Duration
func (_e *MockDriver_Expecter) Set(ctx interface{}, key interface{}, value interface{}, ttl interface{}) *MockDriver_Set_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Set_Call{Call: _e.mock.On("Set", ctx, key, value, ttl)}
}</span>

func (_c *MockDriver_Set_Call) Run(run func(ctx context.Context, key string, value interface{}, ttl time.Duration)) *MockDriver_Set_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Set_Call) Return(_a0 error) *MockDriver_Set_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Set_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) error) *MockDriver_Set_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SetMultiple provides a mock function with given fields: ctx, values, ttl
func (_m *MockDriver) SetMultiple(ctx context.Context, values map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, values, ttl)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetMultiple")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}, time.Duration) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, values, ttl)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_SetMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMultiple'
type MockDriver_SetMultiple_Call struct {
        *mock.Call
}

// SetMultiple is a helper method to define mock.On call
//   - ctx context.Context
//   - values map[string]interface{}
//   - ttl time.Duration
func (_e *MockDriver_Expecter) SetMultiple(ctx interface{}, values interface{}, ttl interface{}) *MockDriver_SetMultiple_Call <span class="cov8" title="1">{
        return &amp;MockDriver_SetMultiple_Call{Call: _e.mock.On("SetMultiple", ctx, values, ttl)}
}</span>

func (_c *MockDriver_SetMultiple_Call) Run(run func(ctx context.Context, values map[string]interface{}, ttl time.Duration)) *MockDriver_SetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(map[string]interface{}), args[2].(time.Duration))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_SetMultiple_Call) Return(_a0 error) *MockDriver_SetMultiple_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_SetMultiple_Call) RunAndReturn(run func(context.Context, map[string]interface{}, time.Duration) error) *MockDriver_SetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stats provides a mock function with given fields: ctx
func (_m *MockDriver) Stats(ctx context.Context) map[string]interface{} <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stats")</span>
        }

        <span class="cov8" title="1">var r0 map[string]interface{}
        if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[string]interface{})
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// MockDriver_Stats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stats'
type MockDriver_Stats_Call struct {
        *mock.Call
}

// Stats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDriver_Expecter) Stats(ctx interface{}) *MockDriver_Stats_Call <span class="cov8" title="1">{
        return &amp;MockDriver_Stats_Call{Call: _e.mock.On("Stats", ctx)}
}</span>

func (_c *MockDriver_Stats_Call) Run(run func(ctx context.Context)) *MockDriver_Stats_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDriver_Stats_Call) Return(_a0 map[string]interface{}) *MockDriver_Stats_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDriver_Stats_Call) RunAndReturn(run func(context.Context) map[string]interface{}) *MockDriver_Stats_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockDriver creates a new instance of MockDriver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDriver(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockDriver <span class="cov8" title="1">{
        mock := &amp;MockDriver{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
        mock "github.com/stretchr/testify/mock"
        driver "go.fork.vn/cache/driver"

        time "time"
)

// MockManager is an autogenerated mock type for the Manager type
type MockManager struct {
        mock.Mock
}

type MockManager_Expecter struct {
        mock *mock.Mock
}

func (_m *MockManager) EXPECT() *MockManager_Expecter <span class="cov0" title="0">{
        return &amp;MockManager_Expecter{mock: &amp;_m.Mock}
}</span>

// AddDriver provides a mock function with given fields: name, _a1
func (_m *MockManager) AddDriver(name string, _a1 driver.Driver) <span class="cov0" title="0">{
        _m.Called(name, _a1)
}</span>

// MockManager_AddDriver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddDriver'
type MockManager_AddDriver_Call struct {
        *mock.Call
}

// AddDriver is a helper method to define mock.On call
//   - name string
//   - _a1 driver.Driver
func (_e *MockManager_Expecter) AddDriver(name interface{}, _a1 interface{}) *MockManager_AddDriver_Call <span class="cov0" title="0">{
        return &amp;MockManager_AddDriver_Call{Call: _e.mock.On("AddDriver", name, _a1)}
}</span>

func (_c *MockManager_AddDriver_Call) Run(run func(name string, _a1 driver.Driver)) *MockManager_AddDriver_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(driver.Driver))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_AddDriver_Call) Return() *MockManager_AddDriver_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockManager_AddDriver_Call) RunAndReturn(run func(string, driver.Driver)) *MockManager_AddDriver_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Close provides a mock function with no fields
func (_m *MockManager) Close() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockManager_Close_Call struct {
        *mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockManager_Expecter) Close() *MockManager_Close_Call <span class="cov0" title="0">{
        return &amp;MockManager_Close_Call{Call: _e.mock.On("Close")}
}</span>

func (_c *MockManager_Close_Call) Run(run func()) *MockManager_Close_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Close_Call) Return(_a0 error) *MockManager_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Close_Call) RunAndReturn(run func() error) *MockManager_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: key
func (_m *MockManager) Delete(key string) error <span class="cov0" title="0">{
        ret := _m.Called(key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(key)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockManager_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - key string
func (_e *MockManager_Expecter) Delete(key interface{}) *MockManager_Delete_Call <span class="cov0" title="0">{
        return &amp;MockManager_Delete_Call{Call: _e.mock.On("Delete", key)}
}</span>

func (_c *MockManager_Delete_Call) Run(run func(key string)) *MockManager_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Delete_Call) Return(_a0 error) *MockManager_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Delete_Call) RunAndReturn(run func(string) error) *MockManager_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteMultiple provides a mock function with given fields: keys
func (_m *MockManager) DeleteMultiple(keys []string) error <span class="cov0" title="0">{
        ret := _m.Called(keys)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteMultiple")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func([]string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(keys)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_DeleteMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMultiple'
type MockManager_DeleteMultiple_Call struct {
        *mock.Call
}

// DeleteMultiple is a helper method to define mock.On call
//   - keys []string
func (_e *MockManager_Expecter) DeleteMultiple(keys interface{}) *MockManager_DeleteMultiple_Call <span class="cov0" title="0">{
        return &amp;MockManager_DeleteMultiple_Call{Call: _e.mock.On("DeleteMultiple", keys)}
}</span>

func (_c *MockManager_DeleteMultiple_Call) Run(run func(keys []string)) *MockManager_DeleteMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_DeleteMultiple_Call) Return(_a0 error) *MockManager_DeleteMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_DeleteMultiple_Call) RunAndReturn(run func([]string) error) *MockManager_DeleteMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Driver provides a mock function with given fields: name
func (_m *MockManager) Driver(name string) (driver.Driver, error) <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Driver")</span>
        }

        <span class="cov0" title="0">var r0 driver.Driver
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (driver.Driver, error)); ok </span><span class="cov0" title="0">{
                return rf(name)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) driver.Driver); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(driver.Driver)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockManager_Driver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Driver'
type MockManager_Driver_Call struct {
        *mock.Call
}

// Driver is a helper method to define mock.On call
//   - name string
func (_e *MockManager_Expecter) Driver(name interface{}) *MockManager_Driver_Call <span class="cov0" title="0">{
        return &amp;MockManager_Driver_Call{Call: _e.mock.On("Driver", name)}
}</span>

func (_c *MockManager_Driver_Call) Run(run func(name string)) *MockManager_Driver_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Driver_Call) Return(_a0 driver.Driver, _a1 error) *MockManager_Driver_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockManager_Driver_Call) RunAndReturn(run func(string) (driver.Driver, error)) *MockManager_Driver_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Flush provides a mock function with no fields
func (_m *MockManager) Flush() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Flush")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockManager_Flush_Call struct {
        *mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *MockManager_Expecter) Flush() *MockManager_Flush_Call <span class="cov0" title="0">{
        return &amp;MockManager_Flush_Call{Call: _e.mock.On("Flush")}
}</span>

func (_c *MockManager_Flush_Call) Run(run func()) *MockManager_Flush_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Flush_Call) Return(_a0 error) *MockManager_Flush_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Flush_Call) RunAndReturn(run func() error) *MockManager_Flush_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Get provides a mock function with given fields: key
func (_m *MockManager) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        ret := _m.Called(key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov0" title="0">var r0 interface{}
        var r1 bool
        if rf, ok := ret.Get(0).(func(string) (interface{}, bool)); ok </span><span class="cov0" title="0">{
                return rf(key)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(key)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(interface{})
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(key)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockManager_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockManager_Get_Call struct {
        *mock.Call
}

// Get is a helper method to define mock.On call
//   - key string
func (_e *MockManager_Expecter) Get(key interface{}) *MockManager_Get_Call <span class="cov0" title="0">{
        return &amp;MockManager_Get_Call{Call: _e.mock.On("Get", key)}
}</span>

func (_c *MockManager_Get_Call) Run(run func(key string)) *MockManager_Get_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Get_Call) Return(_a0 interface{}, _a1 bool) *MockManager_Get_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockManager_Get_Call) RunAndReturn(run func(string) (interface{}, bool)) *MockManager_Get_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetMultiple provides a mock function with given fields: keys
func (_m *MockManager) GetMultiple(keys []string) (map[string]interface{}, []string) <span class="cov0" title="0">{
        ret := _m.Called(keys)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMultiple")</span>
        }

        <span class="cov0" title="0">var r0 map[string]interface{}
        var r1 []string
        if rf, ok := ret.Get(0).(func([]string) (map[string]interface{}, []string)); ok </span><span class="cov0" title="0">{
                return rf(keys)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func([]string) map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(keys)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(map[string]interface{})
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func([]string) []string); ok </span><span class="cov0" title="0">{
                r1 = rf(keys)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).([]string)
                }</span>
        }

        <span class="cov0" title="0">return r0, r1</span>
}

// MockManager_GetMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMultiple'
type MockManager_GetMultiple_Call struct {
        *mock.Call
}

// GetMultiple is a helper method to define mock.On call
//   - keys []string
func (_e *MockManager_Expecter) GetMultiple(keys interface{}) *MockManager_GetMultiple_Call <span class="cov0" title="0">{
        return &amp;MockManager_GetMultiple_Call{Call: _e.mock.On("GetMultiple", keys)}
}</span>

func (_c *MockManager_GetMultiple_Call) Run(run func(keys []string)) *MockManager_GetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_GetMultiple_Call) Return(_a0 map[string]interface{}, _a1 []string) *MockManager_GetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockManager_GetMultiple_Call) RunAndReturn(run func([]string) (map[string]interface{}, []string)) *MockManager_GetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Has provides a mock function with given fields: key
func (_m *MockManager) Has(key string) bool <span class="cov0" title="0">{
        ret := _m.Called(key)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Has")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(key)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type MockManager_Has_Call struct {
        *mock.Call
}

// Has is a helper method to define mock.On call
//   - key string
func (_e *MockManager_Expecter) Has(key interface{}) *MockManager_Has_Call <span class="cov0" title="0">{
        return &amp;MockManager_Has_Call{Call: _e.mock.On("Has", key)}
}</span>

func (_c *MockManager_Has_Call) Run(run func(key string)) *MockManager_Has_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Has_Call) Return(_a0 bool) *MockManager_Has_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Has_Call) RunAndReturn(run func(string) bool) *MockManager_Has_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Remember provides a mock function with given fields: key, ttl, callback
func (_m *MockManager) Remember(key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        ret := _m.Called(key, ttl, callback)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Remember")</span>
        }

        <span class="cov0" title="0">var r0 interface{}
        var r1 error
        if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) (interface{}, error)); ok </span><span class="cov0" title="0">{
                return rf(key, ttl, callback)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(key, ttl, callback)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(interface{})
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, time.Duration, func() (interface{}, error)) error); ok </span><span class="cov0" title="0">{
                r1 = rf(key, ttl, callback)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockManager_Remember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remember'
type MockManager_Remember_Call struct {
        *mock.Call
}

// Remember is a helper method to define mock.On call
//   - key string
//   - ttl time.Duration
//   - callback func()(interface{} , error)
func (_e *MockManager_Expecter) Remember(key interface{}, ttl interface{}, callback interface{}) *MockManager_Remember_Call <span class="cov0" title="0">{
        return &amp;MockManager_Remember_Call{Call: _e.mock.On("Remember", key, ttl, callback)}
}</span>

func (_c *MockManager_Remember_Call) Run(run func(key string, ttl time.Duration, callback func() (interface{}, error))) *MockManager_Remember_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(time.Duration), args[2].(func() (interface{}, error)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Remember_Call) Return(_a0 interface{}, _a1 error) *MockManager_Remember_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockManager_Remember_Call) RunAndReturn(run func(string, time.Duration, func() (interface{}, error)) (interface{}, error)) *MockManager_Remember_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Set provides a mock function with given fields: key, value, ttl
func (_m *MockManager) Set(key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        ret := _m.Called(key, value, ttl)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Set")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) error); ok </span><span class="cov0" title="0">{
                r0 = rf(key, value, ttl)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockManager_Set_Call struct {
        *mock.Call
}

// Set is a helper method to define mock.On call
//   - key string
//   - value interface{}
//   - ttl time.Duration
func (_e *MockManager_Expecter) Set(key interface{}, value interface{}, ttl interface{}) *MockManager_Set_Call <span class="cov0" title="0">{
        return &amp;MockManager_Set_Call{Call: _e.mock.On("Set", key, value, ttl)}
}</span>

func (_c *MockManager_Set_Call) Run(run func(key string, value interface{}, ttl time.Duration)) *MockManager_Set_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(interface{}), args[2].(time.Duration))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Set_Call) Return(_a0 error) *MockManager_Set_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Set_Call) RunAndReturn(run func(string, interface{}, time.Duration) error) *MockManager_Set_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SetDefaultDriver provides a mock function with given fields: name
func (_m *MockManager) SetDefaultDriver(name string) <span class="cov0" title="0">{
        _m.Called(name)
}</span>

// MockManager_SetDefaultDriver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDefaultDriver'
type MockManager_SetDefaultDriver_Call struct {
        *mock.Call
}

// SetDefaultDriver is a helper method to define mock.On call
//   - name string
func (_e *MockManager_Expecter) SetDefaultDriver(name interface{}) *MockManager_SetDefaultDriver_Call <span class="cov0" title="0">{
        return &amp;MockManager_SetDefaultDriver_Call{Call: _e.mock.On("SetDefaultDriver", name)}
}</span>

func (_c *MockManager_SetDefaultDriver_Call) Run(run func(name string)) *MockManager_SetDefaultDriver_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_SetDefaultDriver_Call) Return() *MockManager_SetDefaultDriver_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockManager_SetDefaultDriver_Call) RunAndReturn(run func(string)) *MockManager_SetDefaultDriver_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// SetMultiple provides a mock function with given fields: values, ttl
func (_m *MockManager) SetMultiple(values map[string]interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        ret := _m.Called(values, ttl)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetMultiple")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(map[string]interface{}, time.Duration) error); ok </span><span class="cov0" title="0">{
                r0 = rf(values, ttl)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockManager_SetMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMultiple'
type MockManager_SetMultiple_Call struct {
        *mock.Call
}

// SetMultiple is a helper method to define mock.On call
//   - values map[string]interface{}
//   - ttl time.Duration
func (_e *MockManager_Expecter) SetMultiple(values interface{}, ttl interface{}) *MockManager_SetMultiple_Call <span class="cov0" title="0">{
        return &amp;MockManager_SetMultiple_Call{Call: _e.mock.On("SetMultiple", values, ttl)}
}</span>

func (_c *MockManager_SetMultiple_Call) Run(run func(values map[string]interface{}, ttl time.Duration)) *MockManager_SetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(map[string]interface{}), args[1].(time.Duration))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_SetMultiple_Call) Return(_a0 error) *MockManager_SetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_SetMultiple_Call) RunAndReturn(run func(map[string]interface{}, time.Duration) error) *MockManager_SetMultiple_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stats provides a mock function with no fields
func (_m *MockManager) Stats() map[string]map[string]interface{} <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stats")</span>
        }

        <span class="cov0" title="0">var r0 map[string]map[string]interface{}
        if rf, ok := ret.Get(0).(func() map[string]map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(map[string]map[string]interface{})
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockManager_Stats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stats'
type MockManager_Stats_Call struct {
        *mock.Call
}

// Stats is a helper method to define mock.On call
func (_e *MockManager_Expecter) Stats() *MockManager_Stats_Call <span class="cov0" title="0">{
        return &amp;MockManager_Stats_Call{Call: _e.mock.On("Stats")}
}</span>

func (_c *MockManager_Stats_Call) Run(run func()) *MockManager_Stats_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockManager_Stats_Call) Return(_a0 map[string]map[string]interface{}) *MockManager_Stats_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockManager_Stats_Call) RunAndReturn(run func() map[string]map[string]interface{}) *MockManager_Stats_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockManager creates a new instance of MockManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockManager(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockManager <span class="cov0" title="0">{
        mock := &amp;MockManager{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
        mock "github.com/stretchr/testify/mock"
        di "go.fork.vn/di"
)

// MockServiceProvider is an autogenerated mock type for the ServiceProvider type
type MockServiceProvider struct {
        mock.Mock
}

type MockServiceProvider_Expecter struct {
        mock *mock.Mock
}

func (_m *MockServiceProvider) EXPECT() *MockServiceProvider_Expecter <span class="cov0" title="0">{
        return &amp;MockServiceProvider_Expecter{mock: &amp;_m.Mock}
}</span>

// Boot provides a mock function with given fields: app
func (_m *MockServiceProvider) Boot(app di.Application) <span class="cov0" title="0">{
        _m.Called(app)
}</span>

// MockServiceProvider_Boot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Boot'
type MockServiceProvider_Boot_Call struct {
        *mock.Call
}

// Boot is a helper method to define mock.On call
//   - app di.Application
func (_e *MockServiceProvider_Expecter) Boot(app interface{}) *MockServiceProvider_Boot_Call <span class="cov0" title="0">{
        return &amp;MockServiceProvider_Boot_Call{Call: _e.mock.On("Boot", app)}
}</span>

func (_c *MockServiceProvider_Boot_Call) Run(run func(app di.Application)) *MockServiceProvider_Boot_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(di.Application))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockServiceProvider_Boot_Call) Return() *MockServiceProvider_Boot_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockServiceProvider_Boot_Call) RunAndReturn(run func(di.Application)) *MockServiceProvider_Boot_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Providers provides a mock function with no fields
func (_m *MockServiceProvider) Providers() []string <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Providers")</span>
        }

        <span class="cov0" title="0">var r0 []string
        if rf, ok := ret.Get(0).(func() []string); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]string)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockServiceProvider_Providers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Providers'
type MockServiceProvider_Providers_Call struct {
        *mock.Call
}

// Providers is a helper method to define mock.On call
func (_e *MockServiceProvider_Expecter) Providers() *MockServiceProvider_Providers_Call <span class="cov0" title="0">{
        return &amp;MockServiceProvider_Providers_Call{Call: _e.mock.On("Providers")}
}</span>

func (_c *MockServiceProvider_Providers_Call) Run(run func()) *MockServiceProvider_Providers_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockServiceProvider_Providers_Call) Return(_a0 []string) *MockServiceProvider_Providers_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockServiceProvider_Providers_Call) RunAndReturn(run func() []string) *MockServiceProvider_Providers_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Register provides a mock function with given fields: app
func (_m *MockServiceProvider) Register(app di.Application) <span class="cov0" title="0">{
        _m.Called(app)
}</span>

// MockServiceProvider_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type MockServiceProvider_Register_Call struct {
        *mock.Call
}

// Register is a helper method to define mock.On call
//   - app di.Application
func (_e *MockServiceProvider_Expecter) Register(app interface{}) *MockServiceProvider_Register_Call <span class="cov0" title="0">{
        return &amp;MockServiceProvider_Register_Call{Call: _e.mock.On("Register", app)}
}</span>

func (_c *MockServiceProvider_Register_Call) Run(run func(app di.Application)) *MockServiceProvider_Register_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(di.Application))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockServiceProvider_Register_Call) Return() *MockServiceProvider_Register_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockServiceProvider_Register_Call) RunAndReturn(run func(di.Application)) *MockServiceProvider_Register_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Requires provides a mock function with no fields
func (_m *MockServiceProvider) Requires() []string <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Requires")</span>
        }

        <span class="cov0" title="0">var r0 []string
        if rf, ok := ret.Get(0).(func() []string); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]string)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockServiceProvider_Requires_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Requires'
type MockServiceProvider_Requires_Call struct {
        *mock.Call
}

// Requires is a helper method to define mock.On call
func (_e *MockServiceProvider_Expecter) Requires() *MockServiceProvider_Requires_Call <span class="cov0" title="0">{
        return &amp;MockServiceProvider_Requires_Call{Call: _e.mock.On("Requires")}
}</span>

func (_c *MockServiceProvider_Requires_Call) Run(run func()) *MockServiceProvider_Requires_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockServiceProvider_Requires_Call) Return(_a0 []string) *MockServiceProvider_Requires_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockServiceProvider_Requires_Call) RunAndReturn(run func() []string) *MockServiceProvider_Requires_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockServiceProvider creates a new instance of MockServiceProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServiceProvider(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockServiceProvider <span class="cov0" title="0">{
        mock := &amp;MockServiceProvider{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "go.fork.vn/cache/config"
        "go.fork.vn/cache/driver"
        configService "go.fork.vn/config"
        "go.fork.vn/di"
        "go.fork.vn/mongodb"
        "go.fork.vn/redis"
)

// ServiceProvider là interface cho cache service provider.
//
// ServiceProvider định nghĩa các phương thức cần thiết cho một cache service provider
// và kế thừa từ di.ServiceProvider.
type ServiceProvider interface {
        di.ServiceProvider
}

// serviceProvider là service provider cho module cache.
//
// serviceProvider đảm nhận việc đăng ký và khởi tạo các dịch vụ cache vào container DI.
// Nó cung cấp cơ chế để đăng ký cache manager và các driver mặc định vào ứng dụng.
type serviceProvider struct {
        providers []string
}

// NewServiceProvider tạo một cache service provider mới.
//
// Phương thức này khởi tạo một service provider mới cho module cache.
//
// Returns:
//   - ServiceProvider: Đối tượng service provider đã sẵn sàng đăng ký vào ứng dụng
func NewServiceProvider() ServiceProvider <span class="cov8" title="1">{
        return &amp;serviceProvider{}
}</span>

// Requires trả về danh sách các service provider mà provider này phụ thuộc.
//
// Cache provider phụ thuộc vào config provider để đọc cấu hình.
//
// Trả về:
//   - []string: danh sách các service provider khác mà provider này yêu cầu
func (p *serviceProvider) Requires() []string <span class="cov8" title="1">{
        return []string{"config", "redis", "mongodb"}
}</span>

// Register đăng ký các binding vào container.
//
// Phương thức này đăng ký cache manager vào container DI của ứng dụng.
// Nó khởi tạo một cache manager mới và đăng ký nó với khóa "cache".
// Cấu hình sẽ được load từ config manager và các driver được khởi tạo theo cấu hình.
//
// Params:
//   - app: Application instance với DI container và lifecycle management
func (p *serviceProvider) Register(app di.Application) <span class="cov8" title="1">{
        if app == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c := app.Container()

        // Load cache manager và config manager
        configManager := c.MustMake("config").(configService.Manager)

        var cfg config.Config
        if err := configManager.UnmarshalKey("cache", &amp;cfg); err != nil </span><span class="cov8" title="1">{
                panic("Cache config unmarshal error: " + err.Error())</span>
        }

        <span class="cov8" title="1">manager := NewManager()
        // Đăng ký cache service
        c.Instance("cache", manager)
        p.providers = append(p.providers, "cache")

        if cfg.Drivers.Memory != nil &amp;&amp; cfg.Drivers.Memory.Enabled {
                // Đăng ký Memory Driver vào cache manager
                memoryDriver := driver.NewMemoryDriver(*cfg.Drivers.Memory)
                manager.AddDriver("memory", memoryDriver)
                c.Instance("cache.memory", memoryDriver)
                p.providers = append(p.providers, "cache.memory")
</span>        }

        if cfg.Drivers.File != nil &amp;&amp; cfg.Drivers.File.Enabled {
                // Đăng ký File Driver vào cache manager
                fileDriver, err := driver.NewFileDriver(*cfg.Drivers.File)
                </span>if err != nil {
                        panic("Failed to create File driver: " + err.Error())
        <span class="cov8" title="1">        }
</span>                manager.AddDriver("file", fileDriver)
                c.Instance("cache.file", fileDriver)
                p.providers = </span><span class="cov8" title="1">append(p.providers, "cache.file")
        }
</span>
        i<span class="cov8" title="1">f cfg.Drivers.Redis != nil &amp;&amp; cfg.Drivers.Redis.Enabled {
                redisManager := c.MustMake("redis").(redis.Manager)
                if redisManager == nil {
</span>                        panic("Redis manager is nil, please ensure Redis provider is registered")
                }
        <span class="cov8" title="1">        // Đăng ký Redis Driver vào cache manager
</span>                redisDriver, err := driver.NewRedisDriver(*cfg.Drivers.Redis, redisManager)
                if err != nil {
</span>                        panic("Failed to create Redis driver: " + err.Error())
</span>                }
                manager.AddDriver("redis", redisDriver)
                <span class="cov0" title="0">c.Instance("cache.redis", redisDriver)
                p.providers = </span><span class="cov0" title="0">append(p.providers, "cache.redis")
        }
</span>
        i<span class="cov0" title="0">f cfg.Drivers.MongoDB != nil &amp;&amp; cfg.Drivers.MongoDB.Enabled {
                mongodbManager := c.MustMake("mongodb").(mongodb.Manager)
                if mongodbManager == nil {
</span>                        panic("MongoDB manager is nil, please ensure MongoDB provider is registered")
                }

</span>                // Đăng ký MongoDB Driver vào cache manager
                mongodbDriver, err := dri</span><span class="cov0" title="0">ver.NewMongoDBDriver(*cfg.Drivers.MongoDB, mongodbManager)
                if err != nil {
</span>                        panic("Failed to create MongoDB driver: " + err.Error())
                }
                manager.AddDriver("mongodb", mongodbDriver)
                <span class="cov8" title="1">c.Instance("cache.mongodb", mongodbDriver)
                p.providers = </span><span class="cov0" title="0">append(p.providers, "cache.mongodb")
        }
</span>}

// Boot được gọi sau khi tất cả các service provider đã được đăng ký.
//
</span>// Phương thức này thực hiện các thao tác khởi tạo cuối cùng sau khi tất cả provider đã đăng ký.
// Hiện tại không cần thực hiện gì đặc biệt vì tất cả cấu hình đã được thực hiện trong Register.
//
// Params:
//   - app: Application instance với DI container và lifecycle management
func (p *serviceProvider) Boot(app di.Application) {
        if app == nil {
                return
        }
}

// Providers tr</span><span class="cov8" title="1">ả về danh sách các dịch vụ được cung cấp bởi provider.
//
//</span> Trả về:
//   - []string: danh sách các khóa dịch vụ mà provider này cung cấp
func (p *serviceProvider) Providers() []string {
        return p.providers
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
